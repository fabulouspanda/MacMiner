

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>16.2. threading — Higher-level threading interface &mdash; Python v2.7.4 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v2.7.4 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v2.7.4 documentation" href="../index.html" />
    <link rel="up" title="16. Optional Operating System Services" href="someos.html" />
    <link rel="next" title="16.3. thread — Multiple threads of control" href="thread.html" />
    <link rel="prev" title="16.1. select — Waiting for I/O completion" href="select.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — Multiple threads of control"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — Waiting for I/O completion"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="someos.html" accesskey="U">16. Optional Operating System Services</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-threading">
<span id="threading-higher-level-threading-interface"></span><h1>16.2. <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> &#8212; Higher-level threading interface<a class="headerlink" href="#module-threading" title="Permalink to this headline">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="http://hg.python.org/cpython/file/2.7/Lib/threading.py">Lib/threading.py</a></p>
<hr class="docutils" />
<p>This module constructs higher-level threading interfaces on top of the  lower
level <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><tt class="xref py py-mod docutils literal"><span class="pre">thread</span></tt></a> module.
See also the <a class="reference internal" href="mutex.html#module-mutex" title="mutex: Lock and queue for mutual exclusion. (deprecated)"><tt class="xref py py-mod docutils literal"><span class="pre">mutex</span></tt></a> and <a class="reference internal" href="queue.html#module-Queue" title="Queue: A synchronized queue class."><tt class="xref py py-mod docutils literal"><span class="pre">Queue</span></tt></a> modules.</p>
<p>The <a class="reference internal" href="dummy_threading.html#module-dummy_threading" title="dummy_threading: Drop-in replacement for the threading module."><tt class="xref py py-mod docutils literal"><span class="pre">dummy_threading</span></tt></a> module is provided for situations where
<a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> cannot be used because <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><tt class="xref py py-mod docutils literal"><span class="pre">thread</span></tt></a> is missing.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Starting with Python 2.6, this module provides <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> compliant aliases and
properties to replace the <tt class="docutils literal"><span class="pre">camelCase</span></tt> names that were inspired by Java&#8217;s
threading API. This updated API is compatible with that of the
<a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based &quot;threading&quot; interface."><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></tt></a> module. However, no schedule has been set for the
deprecation of the <tt class="docutils literal"><span class="pre">camelCase</span></tt> names and they remain fully supported in
both Python 2.x and 3.x.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Starting with Python 2.5, several Thread methods raise <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a>
instead of <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a> if called erroneously.</p>
</div>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> In CPython, due to the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><em class="xref std std-term">Global Interpreter Lock</em></a>, only one thread
can execute Python code at once (even though certain performance-oriented
libraries might overcome this limitation).
If you want your application to make better use of the computational
resources of multi-core machines, you are advised to use
<a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based &quot;threading&quot; interface."><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></tt></a>. However, threading is still an appropriate model
if you want to run multiple I/O-bound tasks simultaneously.</p>
</div>
<p>This module defines the following functions and objects:</p>
<dl class="function">
<dt id="threading.active_count">
<tt class="descclassname">threading.</tt><tt class="descname">active_count</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.active_count" title="Permalink to this definition">¶</a></dt>
<dt id="threading.activeCount">
<tt class="descclassname">threading.</tt><tt class="descname">activeCount</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.activeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a> objects currently alive.  The returned
count is equal to the length of the list returned by <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><tt class="xref py py-func docutils literal"><span class="pre">enumerate()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">threading.</tt><tt class="descname">Condition</tt><big>(</big><big>)</big></dt>
<dd><p>A factory function that returns a new condition variable object. A condition
variable allows one or more threads to wait until they are notified by another
thread.</p>
<p>See <a class="reference internal" href="#condition-objects"><em>Condition Objects</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="threading.current_thread">
<tt class="descclassname">threading.</tt><tt class="descname">current_thread</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.current_thread" title="Permalink to this definition">¶</a></dt>
<dt id="threading.currentThread">
<tt class="descclassname">threading.</tt><tt class="descname">currentThread</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.currentThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current <a class="reference internal" href="#threading.Thread" title="threading.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a> object, corresponding to the caller&#8217;s thread
of control.  If the caller&#8217;s thread of control was not created through the
<a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> module, a dummy thread object with limited functionality is
returned.</p>
</dd></dl>

<dl class="function">
<dt id="threading.enumerate">
<tt class="descclassname">threading.</tt><tt class="descname">enumerate</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all <a class="reference internal" href="#threading.Thread" title="threading.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a> objects currently alive.  The list
includes daemonic threads, dummy thread objects created by
<a class="reference internal" href="#threading.current_thread" title="threading.current_thread"><tt class="xref py py-func docutils literal"><span class="pre">current_thread()</span></tt></a>, and the main thread.  It excludes terminated threads
and threads that have not yet been started.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">threading.</tt><tt class="descname">Event</tt><big>(</big><big>)</big></dt>
<dd><p>A factory function that returns a new event object.  An event manages a flag
that can be set to true with the <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method and reset to false
with the <tt class="xref py py-meth docutils literal"><span class="pre">clear()</span></tt> method.  The <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method blocks until the flag
is true.</p>
<p>See <a class="reference internal" href="#event-objects"><em>Event Objects</em></a>.</p>
</dd></dl>

<dl class="class">
<dt id="threading.local">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">local</tt><a class="headerlink" href="#threading.local" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that represents thread-local data.  Thread-local data are data whose
values are thread specific.  To manage thread-local data, just create an
instance of <a class="reference internal" href="#threading.local" title="threading.local"><tt class="xref py py-class docutils literal"><span class="pre">local</span></tt></a> (or a subclass) and store attributes on it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mydata</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
<span class="n">mydata</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The instance&#8217;s values will be different for separate threads.</p>
<p>For more details and extensive examples, see the documentation string of the
<tt class="xref py py-mod docutils literal"><span class="pre">_threading_local</span></tt> module.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
</dd></dl>

<dl class="function">
<dt id="threading.Lock">
<tt class="descclassname">threading.</tt><tt class="descname">Lock</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory function that returns a new primitive lock object.  Once a thread has
acquired it, subsequent attempts to acquire it block, until it is released; any
thread may release it.</p>
<p>See <a class="reference internal" href="#lock-objects"><em>Lock Objects</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="threading.RLock">
<tt class="descclassname">threading.</tt><tt class="descname">RLock</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.RLock" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory function that returns a new reentrant lock object. A reentrant lock
must be released by the thread that acquired it. Once a thread has acquired a
reentrant lock, the same thread may acquire it again without blocking; the
thread must release it once for each time it has acquired it.</p>
<p>See <a class="reference internal" href="#rlock-objects"><em>RLock Objects</em></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">threading.</tt><tt class="descname">Semaphore</tt><big>(</big><span class="optional">[</span><em>value</em><span class="optional">]</span><big>)</big></dt>
<dd><p>A factory function that returns a new semaphore object.  A semaphore manages a
counter representing the number of <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> calls minus the number of
<tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> calls, plus an initial value. The <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> method blocks
if necessary until it can return without making the counter negative.  If not
given, <em>value</em> defaults to 1.</p>
<p>See <a class="reference internal" href="#semaphore-objects"><em>Semaphore Objects</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="threading.BoundedSemaphore">
<tt class="descclassname">threading.</tt><tt class="descname">BoundedSemaphore</tt><big>(</big><span class="optional">[</span><em>value</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.BoundedSemaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory function that returns a new bounded semaphore object.  A bounded
semaphore checks to make sure its current value doesn&#8217;t exceed its initial
value.  If it does, <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> is raised. In most situations semaphores
are used to guard resources with limited capacity.  If the semaphore is released
too many times it&#8217;s a sign of a bug.  If not given, <em>value</em> defaults to 1.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Thread</tt></dt>
<dd><p>A class that represents a thread of control.  This class can be safely
subclassed in a limited fashion.</p>
<p>See <a class="reference internal" href="#thread-objects"><em>Thread Objects</em></a>.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Timer</tt></dt>
<dd><p>A thread that executes a function after a specified interval has passed.</p>
<p>See <a class="reference internal" href="#timer-objects"><em>Timer Objects</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="threading.settrace">
<tt class="descclassname">threading.</tt><tt class="descname">settrace</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#threading.settrace" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-1">Set a trace function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> module.
The <em>func</em> will be passed to  <a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><tt class="xref py py-func docutils literal"><span class="pre">sys.settrace()</span></tt></a> for each thread, before its
<tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method is called.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.3.</span></p>
</dd></dl>

<dl class="function">
<dt id="threading.setprofile">
<tt class="descclassname">threading.</tt><tt class="descname">setprofile</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#threading.setprofile" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-2">Set a profile function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> module.
The <em>func</em> will be passed to  <a class="reference internal" href="sys.html#sys.setprofile" title="sys.setprofile"><tt class="xref py py-func docutils literal"><span class="pre">sys.setprofile()</span></tt></a> for each thread, before its
<tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method is called.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.3.</span></p>
</dd></dl>

<dl class="function">
<dt id="threading.stack_size">
<tt class="descclassname">threading.</tt><tt class="descname">stack_size</tt><big>(</big><span class="optional">[</span><em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.stack_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the thread stack size used when creating new threads.  The optional
<em>size</em> argument specifies the stack size to be used for subsequently created
threads, and must be 0 (use platform or configured default) or a positive
integer value of at least 32,768 (32kB). If changing the thread stack size is
unsupported, a <tt class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></tt> is raised.  If the specified stack size is
invalid, a <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> is raised and the stack size is unmodified.  32kB
is currently the minimum supported stack size value to guarantee sufficient
stack space for the interpreter itself.  Note that some platforms may have
particular restrictions on values for the stack size, such as requiring a
minimum stack size &gt; 32kB or requiring allocation in multiples of the system
memory page size - platform documentation should be referred to for more
information (4kB pages are common; using multiples of 4096 for the stack size is
the suggested approach in the absence of more specific information).
Availability: Windows, systems with POSIX threads.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.5.</span></p>
</dd></dl>

<p>Detailed interfaces for the objects are documented below.</p>
<p>The design of this module is loosely based on Java&#8217;s threading model. However,
where Java makes locks and condition variables basic behavior of every object,
they are separate objects in Python.  Python&#8217;s <a class="reference internal" href="#threading.Thread" title="threading.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a> class supports a
subset of the behavior of Java&#8217;s Thread class; currently, there are no
priorities, no thread groups, and threads cannot be destroyed, stopped,
suspended, resumed, or interrupted.  The static methods of Java&#8217;s Thread class,
when implemented, are mapped to module-level functions.</p>
<p>All of the methods described below are executed atomically.</p>
<div class="section" id="thread-objects">
<span id="id1"></span><h2>16.2.1. Thread Objects<a class="headerlink" href="#thread-objects" title="Permalink to this headline">¶</a></h2>
<p>This class represents an activity that is run in a separate thread of control.
There are two ways to specify the activity: by passing a callable object to the
constructor, or by overriding the <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method in a subclass.  No other
methods (except for the constructor) should be overridden in a subclass.  In
other words,  <em>only</em>  override the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> and <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> methods of
this class.</p>
<p>Once a thread object is created, its activity must be started by calling the
thread&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt> method.  This invokes the <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method in a
separate thread of control.</p>
<p>Once the thread&#8217;s activity is started, the thread is considered &#8216;alive&#8217;. It
stops being alive when its <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method terminates &#8211; either normally, or
by raising an unhandled exception.  The <tt class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></tt> method tests whether the
thread is alive.</p>
<p>Other threads can call a thread&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt> method.  This blocks the calling
thread until the thread whose <tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt> method is called is terminated.</p>
<p>A thread has a name.  The name can be passed to the constructor, and read or
changed through the <tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> attribute.</p>
<p>A thread can be flagged as a &#8220;daemon thread&#8221;.  The significance of this flag is
that the entire Python program exits when only daemon threads are left.  The
initial value is inherited from the creating thread.  The flag can be set
through the <tt class="xref py py-attr docutils literal"><span class="pre">daemon</span></tt> property.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Daemon threads are abruptly stopped at shutdown.  Their resources (such
as open files, database transactions, etc.) may not be released properly.
If you want your threads to stop gracefully, make them non-daemonic and
use a suitable signalling mechanism such as an <a class="reference internal" href="#threading.Event" title="threading.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a>.</p>
</div>
<p>There is a &#8220;main thread&#8221; object; this corresponds to the initial thread of
control in the Python program.  It is not a daemon thread.</p>
<p>There is the possibility that &#8220;dummy thread objects&#8221; are created. These are
thread objects corresponding to &#8220;alien threads&#8221;, which are threads of control
started outside the threading module, such as directly from C code.  Dummy
thread objects have limited functionality; they are always considered alive and
daemonic, and cannot be <tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt>ed.  They are never deleted, since it is
impossible to detect the termination of alien threads.</p>
<dl class="class">
<dt id="threading.Thread">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Thread</tt><big>(</big><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#threading.Thread" title="Permalink to this definition">¶</a></dt>
<dd><p>This constructor should always be called with keyword arguments.  Arguments
are:</p>
<p><em>group</em> should be <tt class="xref docutils literal"><span class="pre">None</span></tt>; reserved for future extension when a
<tt class="xref py py-class docutils literal"><span class="pre">ThreadGroup</span></tt> class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method.
Defaults to <tt class="xref docutils literal"><span class="pre">None</span></tt>, meaning nothing is called.</p>
<p><em>name</em> is the thread name.  By default, a unique name is constructed of the
form &#8220;Thread-<em>N</em>&#8221; where <em>N</em> is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation.  Defaults to <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target invocation.
Defaults to <tt class="docutils literal"><span class="pre">{}</span></tt>.</p>
<p>If the subclass overrides the constructor, it must make sure to invoke the
base class constructor (<tt class="docutils literal"><span class="pre">Thread.__init__()</span></tt>) before doing anything else to
the thread.</p>
<dl class="method">
<dt id="threading.Thread.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the thread&#8217;s activity.</p>
<p>It must be called at most once per thread object.  It arranges for the
object&#8217;s <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method to be invoked in a separate thread of control.</p>
<p>This method will raise a <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> if called more than once
on the same thread object.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Method representing the thread&#8217;s activity.</p>
<p>You may override this method in a subclass.  The standard <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a>
method invokes the callable object passed to the object&#8217;s constructor as
the <em>target</em> argument, if any, with sequential and keyword arguments taken
from the <em>args</em> and <em>kwargs</em> arguments, respectively.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.join">
<tt class="descname">join</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Thread.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until the thread terminates. This blocks the calling thread until the
thread whose <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> method is called terminates &#8211; either normally
or through an unhandled exception &#8211; or until the optional timeout occurs.</p>
<p>When the <em>timeout</em> argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> always returns <tt class="xref docutils literal"><span class="pre">None</span></tt>, you must
call <a class="reference internal" href="#threading.Thread.isAlive" title="threading.Thread.isAlive"><tt class="xref py py-meth docutils literal"><span class="pre">isAlive()</span></tt></a> after <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> to decide whether a timeout
happened &#8211; if the thread is still alive, the <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> call timed out.</p>
<p>When the <em>timeout</em> argument is not present or <tt class="xref docutils literal"><span class="pre">None</span></tt>, the operation will
block until the thread terminates.</p>
<p>A thread can be <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a>ed many times.</p>
<p><a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> raises a <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> if an attempt is made to join
the current thread as that would cause a deadlock. It is also an error to
<a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> a thread before it has been started and attempts to do so
raises the same exception.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.getName">
<tt class="descname">getName</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.getName" title="Permalink to this definition">¶</a></dt>
<dt id="threading.Thread.setName">
<tt class="descname">setName</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.setName" title="Permalink to this definition">¶</a></dt>
<dd><p>Old API for <a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.name">
<tt class="descname">name</tt><a class="headerlink" href="#threading.Thread.name" title="Permalink to this definition">¶</a></dt>
<dd><p>A string used for identification purposes only. It has no semantics.
Multiple threads may be given the same name.  The initial name is set by
the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.ident">
<tt class="descname">ident</tt><a class="headerlink" href="#threading.Thread.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#8216;thread identifier&#8217; of this thread or <tt class="xref docutils literal"><span class="pre">None</span></tt> if the thread has not
been started.  This is a nonzero integer.  See the
<a class="reference internal" href="thread.html#thread.get_ident" title="thread.get_ident"><tt class="xref py py-func docutils literal"><span class="pre">thread.get_ident()</span></tt></a> function.  Thread identifiers may be recycled
when a thread exits and another thread is created.  The identifier is
available even after the thread has exited.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.6.</span></p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.is_alive">
<tt class="descname">is_alive</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.is_alive" title="Permalink to this definition">¶</a></dt>
<dt id="threading.Thread.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the thread is alive.</p>
<p>This method returns <tt class="xref docutils literal"><span class="pre">True</span></tt> just before the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method starts
until just after the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method terminates.  The module function
<a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><tt class="xref py py-func docutils literal"><span class="pre">enumerate()</span></tt></a> returns a list of all alive threads.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.isDaemon">
<tt class="descname">isDaemon</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.isDaemon" title="Permalink to this definition">¶</a></dt>
<dt id="threading.Thread.setDaemon">
<tt class="descname">setDaemon</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Thread.setDaemon" title="Permalink to this definition">¶</a></dt>
<dd><p>Old API for <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><tt class="xref py py-attr docutils literal"><span class="pre">daemon</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.daemon">
<tt class="descname">daemon</tt><a class="headerlink" href="#threading.Thread.daemon" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean value indicating whether this thread is a daemon thread (True)
or not (False).  This must be set before <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> is called,
otherwise <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.  Its initial value is inherited
from the creating thread; the main thread is not a daemon thread and
therefore all threads created in the main thread default to <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><tt class="xref py py-attr docutils literal"><span class="pre">daemon</span></tt></a>
= <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
<p>The entire Python program exits when no alive non-daemon threads are left.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lock-objects">
<span id="id2"></span><h2>16.2.2. Lock Objects<a class="headerlink" href="#lock-objects" title="Permalink to this headline">¶</a></h2>
<p>A primitive lock is a synchronization primitive that is not owned by a
particular thread when locked.  In Python, it is currently the lowest level
synchronization primitive available, implemented directly by the <a class="reference internal" href="thread.html#module-thread" title="thread: Create multiple threads of control within one interpreter."><tt class="xref py py-mod docutils literal"><span class="pre">thread</span></tt></a>
extension module.</p>
<p>A primitive lock is in one of two states, &#8220;locked&#8221; or &#8220;unlocked&#8221;. It is created
in the unlocked state.  It has two basic methods, <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt>.  When the state is unlocked, <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> changes the state
to locked and returns immediately.  When the state is locked, <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt>
blocks until a call to <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> in another thread changes it to unlocked,
then the <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> call resets it to locked and returns.  The
<tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> method should only be called in the locked state; it changes the
state to unlocked and returns immediately. If an attempt is made to release an
unlocked lock, a <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> will be raised.</p>
<p>When more than one thread is blocked in <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> waiting for the state to
turn to unlocked, only one thread proceeds when a <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> call resets
the state to unlocked; which one of the waiting threads proceeds is not defined,
and may vary across implementations.</p>
<p>All methods are executed atomically.</p>
<dl class="method">
<dt id="threading.Lock.acquire">
<tt class="descclassname">Lock.</tt><tt class="descname">acquire</tt><big>(</big><span class="optional">[</span><em>blocking</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Lock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a lock, blocking or non-blocking.</p>
<p>When invoked with the <em>blocking</em> argument set to <tt class="xref docutils literal"><span class="pre">True</span></tt> (the default),
block until the lock is unlocked, then set it to locked and return <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<p>When invoked with the <em>blocking</em> argument set to <tt class="xref docutils literal"><span class="pre">False</span></tt>, do not block.
If a call with <em>blocking</em> set to <tt class="xref docutils literal"><span class="pre">True</span></tt> would block, return <tt class="xref docutils literal"><span class="pre">False</span></tt>
immediately; otherwise, set the lock to locked and return <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Lock.release">
<tt class="descclassname">Lock.</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Lock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a lock.</p>
<p>When the lock is locked, reset it to unlocked, and return.  If any other threads
are blocked waiting for the lock to become unlocked, allow exactly one of them
to proceed.</p>
<p>When invoked on an unlocked lock, a <tt class="xref py py-exc docutils literal"><span class="pre">ThreadError</span></tt> is raised.</p>
<p>There is no return value.</p>
</dd></dl>

</div>
<div class="section" id="rlock-objects">
<span id="id3"></span><h2>16.2.3. RLock Objects<a class="headerlink" href="#rlock-objects" title="Permalink to this headline">¶</a></h2>
<p>A reentrant lock is a synchronization primitive that may be acquired multiple
times by the same thread.  Internally, it uses the concepts of &#8220;owning thread&#8221;
and &#8220;recursion level&#8221; in addition to the locked/unlocked state used by primitive
locks.  In the locked state, some thread owns the lock; in the unlocked state,
no thread owns it.</p>
<p>To lock the lock, a thread calls its <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> method; this returns once
the thread owns the lock.  To unlock the lock, a thread calls its
<tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> method. <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt>/<tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> call pairs may be
nested; only the final <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> (the <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> of the outermost
pair) resets the lock to unlocked and allows another thread blocked in
<tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> to proceed.</p>
<dl class="method">
<dt id="threading.RLock.acquire">
<tt class="descclassname">RLock.</tt><tt class="descname">acquire</tt><big>(</big><span class="optional">[</span><em>blocking=1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.RLock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a lock, blocking or non-blocking.</p>
<p>When invoked without arguments: if this thread already owns the lock, increment
the recursion level by one, and return immediately.  Otherwise, if another
thread owns the lock, block until the lock is unlocked.  Once the lock is
unlocked (not owned by any thread), then grab ownership, set the recursion level
to one, and return.  If more than one thread is blocked waiting until the lock
is unlocked, only one at a time will be able to grab ownership of the lock.
There is no return value in this case.</p>
<p>When invoked with the <em>blocking</em> argument set to true, do the same thing as when
called without arguments, and return true.</p>
<p>When invoked with the <em>blocking</em> argument set to false, do not block.  If a call
without an argument would block, return false immediately; otherwise, do the
same thing as when called without arguments, and return true.</p>
</dd></dl>

<dl class="method">
<dt id="threading.RLock.release">
<tt class="descclassname">RLock.</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.RLock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a lock, decrementing the recursion level.  If after the decrement it is
zero, reset the lock to unlocked (not owned by any thread), and if any other
threads are blocked waiting for the lock to become unlocked, allow exactly one
of them to proceed.  If after the decrement the recursion level is still
nonzero, the lock remains locked and owned by the calling thread.</p>
<p>Only call this method when the calling thread owns the lock. A
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised if this method is called when the lock is
unlocked.</p>
<p>There is no return value.</p>
</dd></dl>

</div>
<div class="section" id="condition-objects">
<span id="id4"></span><h2>16.2.4. Condition Objects<a class="headerlink" href="#condition-objects" title="Permalink to this headline">¶</a></h2>
<p>A condition variable is always associated with some kind of lock; this can be
passed in or one will be created by default.  (Passing one in is useful when
several condition variables must share the same lock.)</p>
<p>A condition variable has <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> methods that call
the corresponding methods of the associated lock. It also has a <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>
method, and <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> methods.  These three must only
be called when the calling thread has acquired the lock, otherwise a
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method releases the lock, and then blocks until it is awakened
by a <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> call for the same condition variable in
another thread.  Once awakened, it re-acquires the lock and returns.  It is also
possible to specify a timeout.</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> method wakes up one of the threads waiting for the condition
variable, if any are waiting.  The <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> method wakes up all threads
waiting for the condition variable.</p>
<p>Note: the <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> methods don&#8217;t release the lock;
this means that the thread or threads awakened will not return from their
<tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> call immediately, but only when the thread that called
<tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> finally relinquishes ownership of the lock.</p>
<p>Tip: the typical programming style using condition variables uses the lock to
synchronize access to some shared state; threads that are interested in a
particular change of state call <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> repeatedly until they see the
desired state, while threads that modify the state call <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> or
<tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt> when they change the state in such a way that it could
possibly be a desired state for one of the waiters.  For example, the following
code is a generic producer-consumer situation with unlimited buffer capacity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Consume one item</span>
<span class="n">cv</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">an_item_is_available</span><span class="p">():</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="n">get_an_available_item</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c"># Produce one item</span>
<span class="n">cv</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">make_an_item_available</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
<span class="n">cv</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>To choose between <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt>, consider whether one
state change can be interesting for only one or several waiting threads.  E.g.
in a typical producer-consumer situation, adding one item to the buffer only
needs to wake up one consumer thread.</p>
<dl class="class">
<dt id="threading.Condition">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Condition</tt><big>(</big><span class="optional">[</span><em>lock</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Condition" title="Permalink to this definition">¶</a></dt>
<dd><p>If the <em>lock</em> argument is given and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it must be a <a class="reference internal" href="#threading.Lock" title="threading.Lock"><tt class="xref py py-class docutils literal"><span class="pre">Lock</span></tt></a>
or <a class="reference internal" href="#threading.RLock" title="threading.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a> object, and it is used as the underlying lock.  Otherwise,
a new <a class="reference internal" href="#threading.RLock" title="threading.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a> object is created and used as the underlying lock.</p>
<dl class="method">
<dt id="threading.Condition.acquire">
<tt class="descname">acquire</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#threading.Condition.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the underlying lock. This method calls the corresponding method on
the underlying lock; the return value is whatever that method returns.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Condition.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the underlying lock. This method calls the corresponding method on
the underlying lock; there is no return value.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.wait">
<tt class="descname">wait</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Condition.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until notified or until a timeout occurs. If the calling thread has not
acquired the lock when this method is called, a <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>This method releases the underlying lock, and then blocks until it is
awakened by a <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a> or <a class="reference internal" href="#threading.Condition.notifyAll" title="threading.Condition.notifyAll"><tt class="xref py py-meth docutils literal"><span class="pre">notifyAll()</span></tt></a> call for the same
condition variable in another thread, or until the optional timeout
occurs.  Once awakened or timed out, it re-acquires the lock and returns.</p>
<p>When the <em>timeout</em> argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof).</p>
<p>When the underlying lock is an <a class="reference internal" href="#threading.RLock" title="threading.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a>, it is not released using
its <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> method, since this may not actually unlock the lock
when it was acquired multiple times recursively.  Instead, an internal
interface of the <a class="reference internal" href="#threading.RLock" title="threading.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a> class is used, which really unlocks it
even when it has been recursively acquired several times. Another internal
interface is then used to restore the recursion level when the lock is
reacquired.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify">
<tt class="descname">notify</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#threading.Condition.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, wake up one thread waiting on this condition, if any.  If the
calling thread has not acquired the lock when this method is called, a
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>This method wakes up at most <em>n</em> of the threads waiting for the condition
variable; it is a no-op if no threads are waiting.</p>
<p>The current implementation wakes up exactly <em>n</em> threads, if at least <em>n</em>
threads are waiting.  However, it&#8217;s not safe to rely on this behavior.
A future, optimized implementation may occasionally wake up more than
<em>n</em> threads.</p>
<p>Note: an awakened thread does not actually return from its <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a>
call until it can reacquire the lock.  Since <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a> does not
release the lock, its caller should.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify_all">
<tt class="descname">notify_all</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Condition.notify_all" title="Permalink to this definition">¶</a></dt>
<dt id="threading.Condition.notifyAll">
<tt class="descname">notifyAll</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Condition.notifyAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake up all threads waiting on this condition.  This method acts like
<a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a>, but wakes up all waiting threads instead of one. If the
calling thread has not acquired the lock when this method is called, a
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="semaphore-objects">
<span id="id5"></span><h2>16.2.5. Semaphore Objects<a class="headerlink" href="#semaphore-objects" title="Permalink to this headline">¶</a></h2>
<p>This is one of the oldest synchronization primitives in the history of computer
science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he
used <tt class="xref py py-meth docutils literal"><span class="pre">P()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">V()</span></tt> instead of <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt>).</p>
<p>A semaphore manages an internal counter which is decremented by each
<tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> call and incremented by each <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> call.  The counter
can never go below zero; when <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> finds that it is zero, it blocks,
waiting until some other thread calls <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt>.</p>
<dl class="class">
<dt id="threading.Semaphore">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Semaphore</tt><big>(</big><span class="optional">[</span><em>value</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Semaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>The optional argument gives the initial <em>value</em> for the internal counter; it
defaults to <tt class="docutils literal"><span class="pre">1</span></tt>. If the <em>value</em> given is less than 0, <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> is
raised.</p>
<dl class="method">
<dt id="threading.Semaphore.acquire">
<tt class="descname">acquire</tt><big>(</big><span class="optional">[</span><em>blocking</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Semaphore.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a semaphore.</p>
<p>When invoked without arguments: if the internal counter is larger than
zero on entry, decrement it by one and return immediately.  If it is zero
on entry, block, waiting until some other thread has called
<a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> to make it larger than zero.  This is done with proper
interlocking so that if multiple <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a> calls are blocked,
<a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> will wake exactly one of them up.  The implementation may
pick one at random, so the order in which blocked threads are awakened
should not be relied on.  There is no return value in this case.</p>
<p>When invoked with <em>blocking</em> set to true, do the same thing as when called
without arguments, and return true.</p>
<p>When invoked with <em>blocking</em> set to false, do not block.  If a call
without an argument would block, return false immediately; otherwise, do
the same thing as when called without arguments, and return true.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Semaphore.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Semaphore.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a semaphore, incrementing the internal counter by one.  When it
was zero on entry and another thread is waiting for it to become larger
than zero again, wake up that thread.</p>
</dd></dl>

</dd></dl>

<div class="section" id="semaphore-example">
<span id="semaphore-examples"></span><h3>16.2.5.1. <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><tt class="xref py py-class docutils literal"><span class="pre">Semaphore</span></tt></a> Example<a class="headerlink" href="#semaphore-example" title="Permalink to this headline">¶</a></h3>
<p>Semaphores are often used to guard resources with limited capacity, for example,
a database server.  In any situation where the size of the resource is fixed,
you should use a bounded semaphore.  Before spawning any worker threads, your
main thread would initialize the semaphore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">maxconnections</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">...</span>
<span class="n">pool_sema</span> <span class="o">=</span> <span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">maxconnections</span><span class="p">)</span>
</pre></div>
</div>
<p>Once spawned, worker threads call the semaphore&#8217;s acquire and release methods
when they need to connect to the server:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pool_sema</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">connectdb</span><span class="p">()</span>
<span class="o">...</span> <span class="n">use</span> <span class="n">connection</span> <span class="o">...</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool_sema</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>The use of a bounded semaphore reduces the chance that a programming error which
causes the semaphore to be released more than it&#8217;s acquired will go undetected.</p>
</div>
</div>
<div class="section" id="event-objects">
<span id="id6"></span><h2>16.2.6. Event Objects<a class="headerlink" href="#event-objects" title="Permalink to this headline">¶</a></h2>
<p>This is one of the simplest mechanisms for communication between threads: one
thread signals an event and other threads wait for it.</p>
<p>An event object manages an internal flag that can be set to true with the
<a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method and reset to false with the <tt class="xref py py-meth docutils literal"><span class="pre">clear()</span></tt> method.  The
<tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method blocks until the flag is true.</p>
<dl class="class">
<dt id="threading.Event">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Event</tt><a class="headerlink" href="#threading.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal flag is initially false.</p>
<dl class="method">
<dt id="threading.Event.is_set">
<tt class="descname">is_set</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Event.is_set" title="Permalink to this definition">¶</a></dt>
<dt id="threading.Event.isSet">
<tt class="descname">isSet</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Event.isSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if and only if the internal flag is true.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.6: </span>The <tt class="docutils literal"><span class="pre">is_set()</span></tt> syntax is new.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.set">
<tt class="descname">set</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Event.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the internal flag to true. All threads waiting for it to become true
are awakened. Threads that call <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> once the flag is true will
not block at all.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Event.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the internal flag to false. Subsequently, threads calling
<a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> will block until <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> is called to set the internal
flag to true again.</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.wait">
<tt class="descname">wait</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#threading.Event.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until the internal flag is true.  If the internal flag is true on
entry, return immediately.  Otherwise, block until another thread calls
<a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> to set the flag to true, or until the optional timeout
occurs.</p>
<p>When the timeout argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof).</p>
<p>This method returns the internal flag on exit, so it will always return
<tt class="xref docutils literal"><span class="pre">True</span></tt> except if a timeout is given and the operation times out.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>Previously, the method always returned <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timer-objects">
<span id="id7"></span><h2>16.2.7. Timer Objects<a class="headerlink" href="#timer-objects" title="Permalink to this headline">¶</a></h2>
<p>This class represents an action that should be run only after a certain amount
of time has passed &#8212; a timer.  <a class="reference internal" href="#threading.Timer" title="threading.Timer"><tt class="xref py py-class docutils literal"><span class="pre">Timer</span></tt></a> is a subclass of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a>
and as such also functions as an example of creating custom threads.</p>
<p>Timers are started, as with threads, by calling their <tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt> method.  The
timer can be stopped (before its action has begun) by calling the <tt class="xref py py-meth docutils literal"><span class="pre">cancel()</span></tt>
method.  The interval the timer will wait before executing its action may not be
exactly the same as the interval specified by the user.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&quot;hello, world&quot;</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">hello</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="c"># after 30 seconds, &quot;hello, world&quot; will be printed</span>
</pre></div>
</div>
<dl class="class">
<dt id="threading.Timer">
<em class="property">class </em><tt class="descclassname">threading.</tt><tt class="descname">Timer</tt><big>(</big><em>interval</em>, <em>function</em>, <em>args=</em><span class="optional">[</span><span class="optional">]</span>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#threading.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a timer that will run <em>function</em> with arguments <em>args</em> and  keyword
arguments <em>kwargs</em>, after <em>interval</em> seconds have passed.</p>
<dl class="method">
<dt id="threading.Timer.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#threading.Timer.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the timer, and cancel the execution of the timer&#8217;s action.  This will
only work if the timer is still in its waiting stage.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="using-locks-conditions-and-semaphores-in-the-with-statement">
<span id="with-locks"></span><h2>16.2.8. Using locks, conditions, and semaphores in the <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> statement<a class="headerlink" href="#using-locks-conditions-and-semaphores-in-the-with-statement" title="Permalink to this headline">¶</a></h2>
<p>All of the objects provided by this module that have <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> methods can be used as context managers for a <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>
statement.  The <tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt> method will be called when the block is entered,
and <tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt> will be called when the block is exited.</p>
<p>Currently, <a class="reference internal" href="#threading.Lock" title="threading.Lock"><tt class="xref py py-class docutils literal"><span class="pre">Lock</span></tt></a>, <a class="reference internal" href="#threading.RLock" title="threading.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a>, <a class="reference internal" href="#threading.Condition" title="threading.Condition"><tt class="xref py py-class docutils literal"><span class="pre">Condition</span></tt></a>,
<a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><tt class="xref py py-class docutils literal"><span class="pre">Semaphore</span></tt></a>, and <a class="reference internal" href="#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><tt class="xref py py-class docutils literal"><span class="pre">BoundedSemaphore</span></tt></a> objects may be used as
<a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> statement context managers.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">threading</span>

<span class="n">some_rlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>

<span class="k">with</span> <span class="n">some_rlock</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;some_rlock is locked while this executes&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="importing-in-threaded-code">
<span id="threaded-imports"></span><h2>16.2.9. Importing in threaded code<a class="headerlink" href="#importing-in-threaded-code" title="Permalink to this headline">¶</a></h2>
<p>While the import machinery is thread-safe, there are two key restrictions on
threaded imports due to inherent limitations in the way that thread-safety is
provided:</p>
<ul class="simple">
<li>Firstly, other than in the main module, an import should not have the
side effect of spawning a new thread and then waiting for that thread in
any way. Failing to abide by this restriction can lead to a deadlock if
the spawned thread directly or indirectly attempts to import a module.</li>
<li>Secondly, all import attempts must be completed before the interpreter
starts shutting itself down. This can be most easily achieved by only
performing imports from non-daemon threads created through the threading
module. Daemon threads and threads created directly with the thread
module will require some other form of synchronization to ensure they do
not attempt imports after system shutdown has commenced. Failure to
abide by this restriction will lead to intermittent exceptions and
crashes during interpreter shutdown (as the late imports attempt to
access machinery which is no longer in a valid state).</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.2. <tt class="docutils literal"><span class="pre">threading</span></tt> &#8212; Higher-level threading interface</a><ul>
<li><a class="reference internal" href="#thread-objects">16.2.1. Thread Objects</a></li>
<li><a class="reference internal" href="#lock-objects">16.2.2. Lock Objects</a></li>
<li><a class="reference internal" href="#rlock-objects">16.2.3. RLock Objects</a></li>
<li><a class="reference internal" href="#condition-objects">16.2.4. Condition Objects</a></li>
<li><a class="reference internal" href="#semaphore-objects">16.2.5. Semaphore Objects</a><ul>
<li><a class="reference internal" href="#semaphore-example">16.2.5.1. <tt class="docutils literal"><span class="pre">Semaphore</span></tt> Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-objects">16.2.6. Event Objects</a></li>
<li><a class="reference internal" href="#timer-objects">16.2.7. Timer Objects</a></li>
<li><a class="reference internal" href="#using-locks-conditions-and-semaphores-in-the-with-statement">16.2.8. Using locks, conditions, and semaphores in the <tt class="docutils literal"><span class="pre">with</span></tt> statement</a></li>
<li><a class="reference internal" href="#importing-in-threaded-code">16.2.9. Importing in threaded code</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="select.html"
                        title="previous chapter">16.1. <tt class="docutils literal docutils literal docutils literal"><span class="pre">select</span></tt> &#8212; Waiting for I/O completion</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="thread.html"
                        title="next chapter">16.3. <tt class="docutils literal docutils literal docutils literal"><span class="pre">thread</span></tt> &#8212; Multiple threads of control</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/threading.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — Multiple threads of control"
             >next</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — Waiting for I/O completion"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="someos.html" >16. Optional Operating System Services</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2013, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Apr 06, 2013.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>