

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>25.3. unittest — Unit testing framework &mdash; Python v2.7.4 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v2.7.4 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v2.7.4 documentation" href="../index.html" />
    <link rel="up" title="25. Development Tools" href="development.html" />
    <link rel="next" title="25.4. 2to3 - Automated Python 2 to 3 code translation" href="2to3.html" />
    <link rel="prev" title="25.2. doctest — Test interactive Python examples" href="doctest.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Automated Python 2 to 3 code translation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — Test interactive Python examples"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="development.html" accesskey="U">25. Development Tools</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1>25.3. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> &#8212; Unit testing framework<a class="headerlink" href="#module-unittest" title="Permalink to this headline">¶</a></h1>
<p class="versionadded">
<span class="versionmodified">New in version 2.1.</span></p>
<p>(If you are already familiar with the basic concepts of testing, you might want
to skip to <a class="reference internal" href="#assert-methods"><em>the list of assert methods</em></a>.)</p>
<p>The Python unit testing framework, sometimes referred to as &#8220;PyUnit,&#8221; is a
Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in
turn, a Java version of Kent&#8217;s Smalltalk testing framework.  Each is the de
facto standard unit testing framework for its respective language.</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> supports test automation, sharing of setup and shutdown code for
tests, aggregation of tests into collections, and independence of the tests from
the reporting framework.  The <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> module provides classes that make
it easy to support these qualities for a set of tests.</p>
<p>To achieve this, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> supports some important concepts:</p>
<dl class="docutils">
<dt>test fixture</dt>
<dd>A <em class="dfn">test fixture</em> represents the preparation needed to perform one or more
tests, and any associate cleanup actions.  This may involve, for example,
creating temporary or proxy databases, directories, or starting a server
process.</dd>
<dt>test case</dt>
<dd>A <em class="dfn">test case</em> is the smallest unit of testing.  It checks for a specific
response to a particular set of inputs.  <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> provides a base class,
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>, which may be used to create new test cases.</dd>
<dt>test suite</dt>
<dd>A <em class="dfn">test suite</em> is a collection of test cases, test suites, or both.  It is
used to aggregate tests that should be executed together.</dd>
<dt>test runner</dt>
<dd>A <em class="dfn">test runner</em> is a component which orchestrates the execution of tests
and provides the outcome to the user.  The runner may use a graphical interface,
a textual interface, or return a special value to indicate the results of
executing the tests.</dd>
</dl>
<p>The test case and test fixture concepts are supported through the
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> and <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> classes; the former should be
used when creating new tests, and the latter can be used when integrating
existing test code with a <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>-driven framework. When building test
fixtures using <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>, the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> and
<a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> methods can be overridden to provide initialization
and cleanup for the fixture.  With <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a>, existing functions
can be passed to the constructor for these purposes.  When the test is run, the
fixture initialization is run first; if it succeeds, the cleanup method is run
after the test has been executed, regardless of the outcome of the test.  Each
instance of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> will only be used to run a single test method,
so a new fixture is created for each test.</p>
<p>Test suites are implemented by the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> class.  This class allows
individual tests and test suites to be aggregated; when the suite is executed,
all tests added directly to the suite and in &#8220;child&#8221; test suites are run.</p>
<p>A test runner is an object that provides a single method,
<tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt>, which accepts a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>
object as a parameter, and returns a result object.  The class
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> is provided for use as the result object. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>
provides the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><tt class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></tt></a> as an example test runner which reports
test results on the standard error stream by default.  Alternate runners can be
implemented for other environments (such as graphical environments) without any
need to derive from a specific class.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Module <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a></dt>
<dd>Another test-support module with a very different flavor.</dd>
<dt><a class="reference external" href="http://pypi.python.org/pypi/unittest2">unittest2: A backport of new unittest features for Python 2.4-2.6</a></dt>
<dd>Many new features were added to unittest in Python 2.7, including test
discovery. unittest2 allows you to use these features with earlier
versions of Python.</dd>
<dt><a class="reference external" href="http://www.XProgramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt>
<dd>Kent Beck&#8217;s original paper on testing frameworks using the pattern shared
by <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>.</dd>
<dt><a class="reference external" href="http://code.google.com/p/python-nose/">Nose</a> and <a class="reference external" href="http://pytest.org">py.test</a></dt>
<dd>Third-party unittest frameworks with a lighter-weight syntax for writing
tests.  For example, <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></tt>.</dd>
<dt><a class="reference external" href="http://pycheesecake.org/wiki/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt>
<dd>An extensive list of Python testing tools including functional testing
frameworks and mock object libraries.</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt>
<dd>A special-interest-group for discussion of testing, and testing tools,
in Python.</dd>
</dl>
</div>
<div class="section" id="basic-example">
<span id="unittest-minimal-example"></span><h2>25.3.1. Basic example<a class="headerlink" href="#basic-example" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> module provides a rich set of tools for constructing and
running tests.  This section demonstrates that a small subset of the tools
suffice to meet the needs of most users.</p>
<p>Here is a short script to test three functions from the <a class="reference internal" href="random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt></a> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestSequenceFunctions</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># make sure the shuffled sequence does not lose any elements</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

        <span class="c"># should raise an exception for an immutable sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">test_choice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>A testcase is created by subclassing <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt></a>.  The three
individual tests are defined with methods whose names start with the letters
<tt class="docutils literal"><span class="pre">test</span></tt>.  This naming convention informs the test runner about which methods
represent tests.</p>
<p>The crux of each test is a call to <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> to check for an
expected result; <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></tt></a> to verify a condition; or
<a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> to verify that an expected exception gets raised.
These methods are used instead of the <a class="reference internal" href="../reference/simple_stmts.html#assert"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> statement so the test
runner can accumulate all test results and produce a report.</p>
<p>When a <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> method is defined, the test runner will run that
method prior to each test.  Likewise, if a <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> method is
defined, the test runner will invoke that method after each test.  In the
example, <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> was used to create a fresh sequence for each
test.</p>
<p>The final block shows a simple way to run the tests. <a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a>
provides a command-line interface to the test script.  When run from the command
line, the above script produces an output that looks like this:</p>
<div class="highlight-python"><pre>...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK</pre>
</div>
<p>Instead of <a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a>, there are other ways to run the tests with a
finer level of control, less terse output, and no requirement to be run from the
command line.  For example, the last two lines may be replaced with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">TestSequenceFunctions</span><span class="p">)</span>
<span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
</pre></div>
</div>
<p>Running the revised script from the interpreter or another script produces the
following output:</p>
<div class="highlight-python"><pre>test_choice (__main__.TestSequenceFunctions) ... ok
test_sample (__main__.TestSequenceFunctions) ... ok
test_shuffle (__main__.TestSequenceFunctions) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.110s

OK</pre>
</div>
<p>The above examples show the most commonly used <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> features which
are sufficient to meet many everyday testing needs.  The remainder of the
documentation explores the full feature set from first principles.</p>
</div>
<div class="section" id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>25.3.2. Command-Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>The unittest module can be used from the command line to run tests from
modules, classes or even individual test methods:</p>
<div class="highlight-python"><pre>python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method</pre>
</div>
<p>You can pass in a list with any combination of module names, and fully
qualified class or method names.</p>
<p>You can run tests with more detail (higher verbosity) by passing in the -v flag:</p>
<div class="highlight-python"><pre>python -m unittest -v test_module</pre>
</div>
<p>For a list of all the command-line options:</p>
<div class="highlight-python"><pre>python -m unittest -h</pre>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>In earlier versions it was only possible to run individual test methods and
not modules or classes.</p>
<div class="section" id="command-line-options">
<h3>25.3.2.1. Command-line options<a class="headerlink" href="#command-line-options" title="Permalink to this headline">¶</a></h3>
<p><strong class="program">unittest</strong> supports these command-line options:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-b">
<tt class="descname">-b</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--buffer</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-b" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard output and standard error streams are buffered during the test
run. Output during a passing test is discarded. Output is echoed normally
on test fail or error and is added to the failure messages.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-c">
<tt class="descname">-c</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--catch</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-c" title="Permalink to this definition">¶</a></dt>
<dd><p>Control-C during the test run waits for the current test to end and then
reports all the results so far. A second control-C raises the normal
<a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><tt class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a> exception.</p>
<p>See <a class="reference internal" href="#signal-handling">Signal Handling</a> for the functions that provide this functionality.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-f">
<tt class="descname">-f</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--failfast</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-f" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the test run on the first error or failure.</p>
</dd></dl>

<p class="versionadded">
<span class="versionmodified">New in version 2.7: </span>The command-line options <tt class="docutils literal"><span class="pre">-b</span></tt>, <tt class="docutils literal"><span class="pre">-c</span></tt> and <tt class="docutils literal"><span class="pre">-f</span></tt> were added.</p>
<p>The command line can also be used for test discovery, for running all of the
tests in a project or just a subset.</p>
</div>
</div>
<div class="section" id="test-discovery">
<span id="unittest-test-discovery"></span><h2>25.3.3. Test Discovery<a class="headerlink" href="#test-discovery" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
<p>Unittest supports simple test discovery. In order to be compatible with test
discovery, all of the test files must be <a class="reference internal" href="../tutorial/modules.html#tut-modules"><em>modules</em></a> or
<a class="reference internal" href="../tutorial/modules.html#tut-packages"><em>packages</em></a> importable from the top-level directory of
the project (this means that their filenames must be valid
<a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><em>identifiers</em></a>).</p>
<p>Test discovery is implemented in <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><tt class="xref py py-meth docutils literal"><span class="pre">TestLoader.discover()</span></tt></a>, but can also be
used from the command line. The basic command-line usage is:</p>
<div class="highlight-python"><pre>cd project_directory
python -m unittest discover</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">discover</span></tt> sub-command has the following options:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-v">
<tt class="descname">-v</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--verbose</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-discover-v" title="Permalink to this definition">¶</a></dt>
<dd><p>Verbose output</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-s">
<tt class="descname">-s</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--start-directory</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-unittest-discover-s" title="Permalink to this definition">¶</a></dt>
<dd><p>Directory to start discovery (<tt class="docutils literal"><span class="pre">.</span></tt> default)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-p">
<tt class="descname">-p</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--pattern</tt><tt class="descclassname"> pattern</tt><a class="headerlink" href="#cmdoption-unittest-discover-p" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern to match test files (<tt class="docutils literal"><span class="pre">test*.py</span></tt> default)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-t">
<tt class="descname">-t</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--top-level-directory</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-unittest-discover-t" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level directory of project (defaults to start directory)</p>
</dd></dl>

<p>The <a class="reference internal" href="#cmdoption-unittest-discover-s"><em class="xref std std-option">-s</em></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><em class="xref std std-option">-p</em></a>, and <a class="reference internal" href="#cmdoption-unittest-discover-t"><em class="xref std std-option">-t</em></a> options can be passed in
as positional arguments in that order. The following two command lines
are equivalent:</p>
<div class="highlight-python"><pre>python -m unittest discover -s project_directory -p '*_test.py'
python -m unittest discover project_directory '*_test.py'</pre>
</div>
<p>As well as being a path it is possible to pass a package name, for example
<tt class="docutils literal"><span class="pre">myproject.subpackage.test</span></tt>, as the start directory. The package name you
supply will then be imported and its location on the filesystem will be used
as the start directory.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p>Test discovery loads tests by importing them. Once test discovery has
found all the test files from the start directory you specify it turns the
paths into package names to import. For example <tt class="file docutils literal"><span class="pre">foo/bar/baz.py</span></tt> will be
imported as <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>.</p>
<p>If you have a package installed globally and attempt test discovery on
a different copy of the package then the import <em>could</em> happen from the
wrong place. If this happens test discovery will warn you and exit.</p>
<p class="last">If you supply the start directory as a package name rather than a
path to a directory then discover assumes that whichever location it
imports from is the location you intended, so you will not get the
warning.</p>
</div>
<p>Test modules and packages can customize test loading and discovery by through
the <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p>
</div>
<div class="section" id="organizing-test-code">
<span id="organizing-tests"></span><h2>25.3.4. Organizing test code<a class="headerlink" href="#organizing-test-code" title="Permalink to this headline">¶</a></h2>
<p>The basic building blocks of unit testing are <em class="dfn">test cases</em> &#8212; single
scenarios that must be set up and checked for correctness.  In <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>,
test cases are represented by instances of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>&#8216;s <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>
class. To make your own test cases you must write subclasses of
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>, or use <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a>.</p>
<p>An instance of a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>-derived class is an object that can
completely run a single test method, together with optional set-up and tidy-up
code.</p>
<p>The testing code of a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instance should be entirely self
contained, such that it can be run either in isolation or in arbitrary
combination with any number of other test cases.</p>
<p>The simplest <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> subclass will simply override the
<tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> method in order to perform specific testing code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that in order to test something, we use one of the <tt class="xref py py-meth docutils literal"><span class="pre">assert*()</span></tt>
methods provided by the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> base class.  If the test fails, an
exception will be raised, and <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> will identify the test case as a
<em class="dfn">failure</em>.  Any other exceptions will be treated as <em class="dfn">errors</em>. This
helps you identify where the problem is: <em class="dfn">failures</em> are caused by incorrect
results - a 5 where you expected a 6. <em class="dfn">Errors</em> are caused by incorrect
code - e.g., a <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> caused by an incorrect function call.</p>
<p>The way to run a test case will be described later.  For now, note that to
construct an instance of such a test case, we call its constructor without
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testCase</span> <span class="o">=</span> <span class="n">DefaultWidgetSizeTestCase</span><span class="p">()</span>
</pre></div>
</div>
<p>Now, such test cases can be numerous, and their set-up can be repetitive.  In
the above case, constructing a <tt class="xref py py-class docutils literal"><span class="pre">Widget</span></tt> in each of 100 Widget test case
subclasses would mean unsightly duplication.</p>
<p>Luckily, we can factor out such set-up code by implementing a method called
<a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a>, which the testing framework will automatically call for
us when we run the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WidgetResizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> method raises an exception while the test is
running, the framework will consider the test to have suffered an error, and the
<tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> method will not be executed.</p>
<p>Similarly, we can provide a <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> method that tidies up
after the <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> method has been run:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> succeeded, the <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> method will
be run whether <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> succeeded or not.</p>
<p>Such a working environment for the testing code is called a <em class="dfn">fixture</em>.</p>
<p>Often, many small test cases will use the same fixture.  In this case, we would
end up subclassing <tt class="xref py py-class docutils literal"><span class="pre">SimpleWidgetTestCase</span></tt> into many small one-method
classes such as <tt class="xref py py-class docutils literal"><span class="pre">DefaultWidgetSizeTestCase</span></tt>.  This is time-consuming and
discouraging, so in the same vein as JUnit, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> provides a simpler
mechanism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">test_default_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we have not provided a <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> method, but have instead
provided two different test methods.  Class instances will now each run one of
the <tt class="xref py py-meth docutils literal"><span class="pre">test_*()</span></tt> methods, with <tt class="docutils literal"><span class="pre">self.widget</span></tt> created and destroyed
separately for each instance.  When creating an instance we must specify the
test method it is to run.  We do this by passing the method name in the
constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">defaultSizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">)</span>
<span class="n">resizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Test case instances are grouped together according to the features they test.
<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> provides a mechanism for this: the <em class="dfn">test suite</em>,
represented by <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>&#8216;s <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">widgetTestSuite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>For the ease of running tests, as we will see later, it is a good idea to
provide in each test module a callable object that returns a pre-built test
suite:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;test_default_size&#39;</span><span class="p">,</span> <span class="s">&#39;test_resize&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">,</span> <span class="n">tests</span><span class="p">))</span>
</pre></div>
</div>
<p>Since it is a common pattern to create a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> subclass with many
similarly named test functions, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> provides a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a>
class that can be used to automate the process of creating a test suite and
populating it with individual tests. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">)</span>
</pre></div>
</div>
<p>will create a test suite that will run <tt class="docutils literal"><span class="pre">WidgetTestCase.test_default_size()</span></tt> and
<tt class="docutils literal"><span class="pre">WidgetTestCase.test_resize</span></tt>. <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> uses the <tt class="docutils literal"><span class="pre">'test'</span></tt> method
name prefix to identify test methods automatically.</p>
<p>Note that the order in which the various test cases will be run is
determined by sorting the test function names with respect to the
built-in ordering for strings.</p>
<p>Often it is desirable to group suites of test cases together, so as to run tests
for the whole system at once.  This is easy, since <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> instances
can be added to a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> just as <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances can be
added to a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite1</span> <span class="o">=</span> <span class="n">module1</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">suite2</span> <span class="o">=</span> <span class="n">module2</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">alltests</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">([</span><span class="n">suite1</span><span class="p">,</span> <span class="n">suite2</span><span class="p">])</span>
</pre></div>
</div>
<p>You can place the definitions of test cases and test suites in the same modules
as the code they are to test (such as <tt class="file docutils literal"><span class="pre">widget.py</span></tt>), but there are several
advantages to placing the test code in a separate module, such as
<tt class="file docutils literal"><span class="pre">test_widget.py</span></tt>:</p>
<ul class="simple">
<li>The test module can be run standalone from the command line.</li>
<li>The test code can more easily be separated from shipped code.</li>
<li>There is less temptation to change test code to fit the code it tests without
a good reason.</li>
<li>Test code should be modified much less frequently than the code it tests.</li>
<li>Tested code can be refactored more easily.</li>
<li>Tests for modules written in C must be in separate modules anyway, so why not
be consistent?</li>
<li>If the testing strategy changes, there is no need to change the source code.</li>
</ul>
</div>
<div class="section" id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>25.3.5. Re-using old test code<a class="headerlink" href="#re-using-old-test-code" title="Permalink to this headline">¶</a></h2>
<p>Some users will find that they have existing test code that they would like to
run from <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>, without converting every old test function to a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> subclass.</p>
<p>For this reason, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> provides a <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> class.
This subclass of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> can be used to wrap an existing test
function.  Set-up and tear-down functions can also be provided.</p>
<p>Given the following test function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="c"># ...</span>
</pre></div>
</div>
<p>one can create an equivalent test case instance as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">)</span>
</pre></div>
</div>
<p>If there are additional set-up and tear-down methods that should be called as
part of the test case&#8217;s operation, they can also be provided like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<p>To make migrating existing test suites easier, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> supports tests
raising <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a> to indicate test failure. However, it is
recommended that you use the explicit <tt class="xref py py-meth docutils literal"><span class="pre">TestCase.fail*()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></tt> methods instead, as future versions of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>
may treat <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a> differently.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even though <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> can be used to quickly convert an
existing test base over to a <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>-based system, this approach is
not recommended.  Taking the time to set up proper <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>
subclasses will make future test refactorings infinitely easier.</p>
</div>
<p>In some cases, the existing tests may have been written using the <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a>
module.  If so, <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a> provides a <tt class="xref py py-class docutils literal"><span class="pre">DocTestSuite</span></tt> class that can
automatically build <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">unittest.TestSuite</span></tt></a> instances from the existing
<a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a>-based tests.</p>
</div>
<div class="section" id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>25.3.6. Skipping tests and expected failures<a class="headerlink" href="#skipping-tests-and-expected-failures" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
<p>Unittest supports skipping individual test methods and even whole classes of
tests.  In addition, it supports marking a test as a &#8220;expected failure,&#8221; a test
that is broken and will fail, but shouldn&#8217;t be counted as a failure on a
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a>.</p>
<p>Skipping a test is simply a matter of using the <a class="reference internal" href="#unittest.skip" title="unittest.skip"><tt class="xref py py-func docutils literal"><span class="pre">skip()</span></tt></a> <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a>
or one of its conditional variants.</p>
<p>Basic skipping looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest.skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest.skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;win&quot;</span><span class="p">),</span> <span class="s">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># windows specific testing code</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>This is the output of running the example above in verbose mode:</p>
<div class="highlight-python"><pre>test_format (__main__.MyTestCase) ... skipped 'not supported in this library version'
test_nothing (__main__.MyTestCase) ... skipped 'demonstrating skipping'
test_windows_support (__main__.MyTestCase) ... skipped 'requires Windows'

----------------------------------------------------------------------
Ran 3 tests in 0.005s

OK (skipped=3)</pre>
</div>
<p>Classes can be skipped just like methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@unittest.skip</span><span class="p">(</span><span class="s">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">TestCase.setUp()</span></tt></a> can also skip the test.  This is useful when a resource
that needs to be set up is not available.</p>
<p>Expected failures use the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> decorator.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest.expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s easy to roll your own skipping decorators by making a decorator that calls
<a class="reference internal" href="#unittest.skip" title="unittest.skip"><tt class="xref py py-func docutils literal"><span class="pre">skip()</span></tt></a> on the test when it wants it to be skipped.  This decorator skips
the test unless the passed object has a certain attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s">&quot;{0!r} doesn&#39;t have {1!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>The following decorators implement test skipping and expected failures:</p>
<dl class="function">
<dt id="unittest.skip">
<tt class="descclassname">unittest.</tt><tt class="descname">skip</tt><big>(</big><em>reason</em><big>)</big><a class="headerlink" href="#unittest.skip" title="Permalink to this definition">¶</a></dt>
<dd><p>Unconditionally skip the decorated test.  <em>reason</em> should describe why the
test is being skipped.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipIf">
<tt class="descclassname">unittest.</tt><tt class="descname">skipIf</tt><big>(</big><em>condition</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.skipIf" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip the decorated test if <em>condition</em> is true.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipUnless">
<tt class="descclassname">unittest.</tt><tt class="descname">skipUnless</tt><big>(</big><em>condition</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.skipUnless" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip the decorated test unless <em>condition</em> is true.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.expectedFailure">
<tt class="descclassname">unittest.</tt><tt class="descname">expectedFailure</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.expectedFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the test as an expected failure.  If the test fails when run, the test
is not counted as a failure.</p>
</dd></dl>

<p>Skipped tests will not have <tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt> run around them.
Skipped classes will not have <tt class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></tt> run.</p>
</div>
<div class="section" id="classes-and-functions">
<span id="unittest-contents"></span><h2>25.3.7. Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this headline">¶</a></h2>
<p>This section describes in depth the API of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>.</p>
<div class="section" id="test-cases">
<span id="testcase-objects"></span><h3>25.3.7.1. Test cases<a class="headerlink" href="#test-cases" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="unittest.TestCase">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestCase</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#unittest.TestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Instances of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> class represent the smallest testable units
in the <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> universe.  This class is intended to be used as a base
class, with specific tests being implemented by concrete subclasses.  This class
implements the interface needed by the test runner to allow it to drive the
test, and methods that the test code can use to check for and report various
kinds of failure.</p>
<p>Each instance of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> will run a single test method: the method
named <em>methodName</em>.  If you remember, we had an earlier example that went
something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>Here, we create two instances of <tt class="xref py py-class docutils literal"><span class="pre">WidgetTestCase</span></tt>, each of which runs a
single test.</p>
<p><em>methodName</em> defaults to <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt>.</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances provide three groups of methods: one group used
to run the test, another used by the test implementation to check conditions
and report failures, and some inquiry methods allowing information about the
test itself to be gathered.</p>
<p>Methods in the first group (running the test) are:</p>
<dl class="method">
<dt id="unittest.TestCase.setUp">
<tt class="descname">setUp</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called to prepare the test fixture.  This is called immediately
before calling the test method; any exception raised by this method will
be considered an error rather than a test failure. The default
implementation does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDown">
<tt class="descname">tearDown</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.tearDown" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called immediately after the test method has been called and the
result recorded.  This is called even if the test method raised an
exception, so the implementation in subclasses may need to be particularly
careful about checking internal state.  Any exception raised by this
method will be considered an error rather than a test failure.  This
method will only be called if the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> succeeds, regardless of
the outcome of the test method. The default implementation does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.setUpClass">
<tt class="descname">setUpClass</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.setUpClass" title="Permalink to this definition">¶</a></dt>
<dd><p>A class method called before tests in an individual class run.
<tt class="docutils literal"><span class="pre">setUpClass</span></tt> is called with the class as the only argument
and must be decorated as a <a class="reference internal" href="functions.html#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> for more details.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDownClass">
<tt class="descname">tearDownClass</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="Permalink to this definition">¶</a></dt>
<dd><p>A class method called after tests in an individual class have run.
<tt class="docutils literal"><span class="pre">tearDownClass</span></tt> is called with the class as the only argument
and must be decorated as a <a class="reference internal" href="functions.html#classmethod" title="classmethod"><tt class="xref py py-meth docutils literal"><span class="pre">classmethod()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> for more details.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.run">
<tt class="descname">run</tt><big>(</big><em>result=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the test, collecting the result into the test result object passed as
<em>result</em>.  If <em>result</em> is omitted or <tt class="xref docutils literal"><span class="pre">None</span></tt>, a temporary result
object is created (by calling the <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><tt class="xref py py-meth docutils literal"><span class="pre">defaultTestResult()</span></tt></a> method) and
used. The result object is not returned to <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a>&#8216;s caller.</p>
<p>The same effect may be had by simply calling the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>
instance.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.skipTest">
<tt class="descname">skipTest</tt><big>(</big><em>reason</em><big>)</big><a class="headerlink" href="#unittest.TestCase.skipTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling this during a test method or <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> skips the current
test.  See <a class="reference internal" href="#unittest-skipping"><em>Skipping tests and expected failures</em></a> for more information.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.debug">
<tt class="descname">debug</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the test without collecting the result.  This allows exceptions raised
by the test to be propagated to the caller, and can be used to support
running tests under a debugger.</p>
</dd></dl>

<p id="assert-methods">The <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> class provides a number of methods to check for and
report failures, such as:</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="34%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Method</th>
<th class="head">Checks that</th>
<th class="head">New in</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><tt class="xref py py-meth docutils literal"><span class="pre">assertFalse(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><tt class="xref py py-meth docutils literal"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNone(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNotNone(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><tt class="xref py py-meth docutils literal"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></tt></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<p>All the assert methods (except <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a>,
<a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp()</span></tt></a>)
accept a <em>msg</em> argument that, if specified, is used as the error message on
failure (see also <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><tt class="xref py py-data docutils literal"><span class="pre">longMessage</span></tt></a>).</p>
<dl class="method">
<dt id="unittest.TestCase.assertEqual">
<tt class="descname">assertEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> and <em>second</em> are equal.  If the values do not compare
equal, the test will fail.</p>
<p>In addition, if <em>first</em> and <em>second</em> are the exact same type and one of
list, tuple, dict, set, frozenset or unicode or any type that a subclass
registers with <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><tt class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></tt></a> the type-specific equality
function will be called in order to generate a more useful default
error message (see also the <a class="reference internal" href="#type-specific-methods"><em>list of type-specific methods</em></a>).</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>Added the automatic calling of type-specific equality function.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotEqual">
<tt class="descname">assertNotEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> and <em>second</em> are not equal.  If the values do compare
equal, the test will fail.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertTrue">
<tt class="descname">assertTrue</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertTrue" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<tt class="descname">assertFalse</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertFalse" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>expr</em> is true (or false).</p>
<p>Note that this is equivalent to <tt class="docutils literal"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></tt> and not to <tt class="docutils literal"><span class="pre">expr</span>
<span class="pre">is</span> <span class="pre">True</span></tt> (use <tt class="docutils literal"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></tt> for the latter).  This method
should also be avoided when more specific methods are available (e.g.
<tt class="docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></tt> instead of <tt class="docutils literal"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></tt>), because they
provide a better error message in case of failure.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIs">
<tt class="descname">assertIs</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIs" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<tt class="descname">assertIsNot</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> and <em>second</em> evaluate (or don&#8217;t evaluate) to the same object.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsNone">
<tt class="descname">assertIsNone</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<tt class="descname">assertIsNotNone</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>expr</em> is (or is not) None.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIn">
<tt class="descname">assertIn</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIn" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<tt class="descname">assertNotIn</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> is (or is not) in <em>second</em>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsInstance">
<tt class="descname">assertIsInstance</tt><big>(</big><em>obj</em>, <em>cls</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<tt class="descname">assertNotIsInstance</tt><big>(</big><em>obj</em>, <em>cls</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>obj</em> is (or is not) an instance of <em>cls</em> (which can be a
class or a tuple of classes, as supported by <a class="reference internal" href="functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a>).
To check for the exact type, use <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><tt class="xref py py-func docutils literal"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p>It is also possible to check that exceptions and warnings are raised using
the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="36%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Method</th>
<th class="head">Checks that</th>
<th class="head">New in</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></tt> raises <em>exc</em></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp(exc,</span> <span class="pre">re,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></tt> raises <em>exc</em>
and the message matches <em>re</em></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertRaises">
<tt class="descname">assertRaises</tt><big>(</big><em>exception</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRaises" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">assertRaises</tt><big>(</big><em>exception</em><big>)</big></dt>
<dd><p>Test that an exception is raised when <em>callable</em> is called with any
positional or keyword arguments that are also passed to
<a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a>.  The test passes if <em>exception</em> is raised, is an
error if another exception is raised, or fails if no exception is raised.
To catch any of a group of exceptions, a tuple containing the exception
classes may be passed as <em>exception</em>.</p>
<p>If only the <em>exception</em> argument is given, returns a context manager so
that the code under test can be written inline rather than as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>The context manager will store the caught exception object in its
<tt class="xref py py-attr docutils literal"><span class="pre">exception</span></tt> attribute.  This can be useful if the intention
is to perform additional checks on the exception raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>Added the ability to use <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> as a context manager.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRaisesRegexp">
<tt class="descname">assertRaisesRegexp</tt><big>(</big><em>exception</em>, <em>regexp</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRaisesRegexp" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">assertRaisesRegexp</tt><big>(</big><em>exception</em>, <em>regexp</em><big>)</big></dt>
<dd><p>Like <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> but also tests that <em>regexp</em> matches
on the string representation of the raised exception.  <em>regexp</em> may be
a regular expression object or a string containing a regular expression
suitable for use by <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a>.  Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;invalid literal for.*XYZ$&#39;</span><span class="p">,</span>
                        <span class="nb">int</span><span class="p">,</span> <span class="s">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p>There are also other methods used to perform more specific checks, such as:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="38%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Method</th>
<th class="head">Checks that</th>
<th class="head">New in</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><tt class="xref py py-meth docutils literal"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><tt class="xref py py-meth docutils literal"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertRegexpMatches" title="unittest.TestCase.assertRegexpMatches"><tt class="xref py py-meth docutils literal"><span class="pre">assertRegexpMatches(s,</span> <span class="pre">re)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">regex.search(s)</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotRegexpMatches" title="unittest.TestCase.assertNotRegexpMatches"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotRegexpMatches(s,</span> <span class="pre">re)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">not</span> <span class="pre">regex.search(s)</span></tt></td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertItemsEqual" title="unittest.TestCase.assertItemsEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertItemsEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sorted(a) == sorted(b) and
works with unhashable objs</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertDictContainsSubset" title="unittest.TestCase.assertDictContainsSubset"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictContainsSubset(a,</span> <span class="pre">b)</span></tt></a></td>
<td>all the key/value pairs
in <em>a</em> exist in <em>b</em></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertAlmostEqual">
<tt class="descname">assertAlmostEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<tt class="descname">assertNotAlmostEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> and <em>second</em> are approximately (or not approximately)
equal by computing the difference, rounding to the given number of
decimal <em>places</em> (default 7), and comparing to zero.  Note that these
methods round the values to the given number of <em>decimal places</em> (i.e.
like the <a class="reference internal" href="functions.html#round" title="round"><tt class="xref py py-func docutils literal"><span class="pre">round()</span></tt></a> function) and not <em>significant digits</em>.</p>
<p>If <em>delta</em> is supplied instead of <em>places</em> then the difference
between <em>first</em> and <em>second</em> must be less (or more) than <em>delta</em>.</p>
<p>Supplying both <em>delta</em> and <em>places</em> raises a <tt class="docutils literal"><span class="pre">TypeError</span></tt>.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></tt></a> automatically considers almost equal objects
that compare equal.  <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></tt></a> automatically fails
if the objects compare equal.  Added the <em>delta</em> keyword argument.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertGreater">
<tt class="descname">assertGreater</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertGreater" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<tt class="descname">assertGreaterEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<tt class="descname">assertLess</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertLess" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<tt class="descname">assertLessEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that <em>first</em> is respectively &gt;, &gt;=, &lt; or &lt;= than <em>second</em> depending
on the method name.  If not, the test will fail:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRegexpMatches">
<tt class="descname">assertRegexpMatches</tt><big>(</big><em>text</em>, <em>regexp</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRegexpMatches" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that a <em>regexp</em> search matches <em>text</em>.  In case
of failure, the error message will include the pattern and the <em>text</em> (or
the pattern and the part of <em>text</em> that unexpectedly matched).  <em>regexp</em>
may be a regular expression object or a string containing a regular
expression suitable for use by <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotRegexpMatches">
<tt class="descname">assertNotRegexpMatches</tt><big>(</big><em>text</em>, <em>regexp</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotRegexpMatches" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies that a <em>regexp</em> search does not match <em>text</em>.  Fails with an error
message including the pattern and the part of <em>text</em> that matches.  <em>regexp</em>
may be a regular expression object or a string containing a regular
expression suitable for use by <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertItemsEqual">
<tt class="descname">assertItemsEqual</tt><big>(</big><em>actual</em>, <em>expected</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertItemsEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that sequence <em>expected</em> contains the same elements as <em>actual</em>,
regardless of their order. When they don&#8217;t, an error message listing the
differences between the sequences will be generated.</p>
<p>Duplicate elements are <em>not</em> ignored when comparing <em>actual</em> and
<em>expected</em>. It verifies if each element has the same count in both
sequences. It is the equivalent of <tt class="docutils literal"><span class="pre">assertEqual(sorted(expected),</span>
<span class="pre">sorted(actual))</span></tt> but it works with sequences of unhashable objects as
well.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictContainsSubset">
<tt class="descname">assertDictContainsSubset</tt><big>(</big><em>expected</em>, <em>actual</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertDictContainsSubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the key/value pairs in dictionary <em>actual</em> are a
superset of those in <em>expected</em>.  If not, an error message listing
the missing keys and mismatched values is generated.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 3.2.</span></p>
</dd></dl>

<p id="type-specific-methods">The <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> method dispatches the equality check for objects of
the same type to different type-specific methods.  These methods are already
implemented for most of the built-in types, but it&#8217;s also possible to
register new methods using <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><tt class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></tt></a>:</p>
<dl class="method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<tt class="descname">addTypeEqualityFunc</tt><big>(</big><em>typeobj</em>, <em>function</em><big>)</big><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a type-specific method called by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> to check
if two objects of exactly the same <em>typeobj</em> (not subclasses) compare
equal.  <em>function</em> must take two positional arguments and a third msg=None
keyword argument just as <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> does.  It must raise
<a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><tt class="xref py py-data docutils literal"><span class="pre">self.failureException(msg)</span></tt></a> when inequality
between the first two parameters is detected &#8211; possibly providing useful
information and explaining the inequalities in details in the error
message.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p>The list of type-specific methods automatically used by
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> are summarized in the following table.  Note
that it&#8217;s usually not necessary to invoke these methods directly.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="35%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Method</th>
<th class="head">Used to compare</th>
<th class="head">New in</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>strings</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sequences</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>lists</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>tuples</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sets or frozensets</td>
<td>2.7</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>dicts</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<tt class="descname">assertMultiLineEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that the multiline string <em>first</em> is equal to the string <em>second</em>.
When not equal a diff of the two strings highlighting the differences
will be included in the error message. This method is used by default
when comparing strings with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSequenceEqual">
<tt class="descname">assertSequenceEqual</tt><big>(</big><em>seq1</em>, <em>seq2</em>, <em>msg=None</em>, <em>seq_type=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests that two sequences are equal.  If a <em>seq_type</em> is supplied, both
<em>seq1</em> and <em>seq2</em> must be instances of <em>seq_type</em> or a failure will
be raised.  If the sequences are different an error message is
constructed that shows the difference between the two.</p>
<p>This method is not called directly by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a>, but
it&#8217;s used to implement <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertListEqual()</span></tt></a> and
<a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertListEqual">
<tt class="descname">assertListEqual</tt><big>(</big><em>list1</em>, <em>list2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="Permalink to this definition">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<tt class="descname">assertTupleEqual</tt><big>(</big><em>tuple1</em>, <em>tuple2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests that two lists or tuples are equal.  If not, an error message is
constructed that shows only the differences between the two.  An error
is also raised if either of the parameters are of the wrong type.
These methods are used by default when comparing lists or tuples with
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSetEqual">
<tt class="descname">assertSetEqual</tt><big>(</big><em>set1</em>, <em>set2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests that two sets are equal.  If not, an error message is constructed
that lists the differences between the sets.  This method is used by
default when comparing sets or frozensets with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a>.</p>
<p>Fails if either of <em>set1</em> or <em>set2</em> does not have a <a class="reference internal" href="stdtypes.html#set.difference" title="set.difference"><tt class="xref py py-meth docutils literal"><span class="pre">set.difference()</span></tt></a>
method.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictEqual">
<tt class="descname">assertDictEqual</tt><big>(</big><em>expected</em>, <em>actual</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that two dictionaries are equal.  If not, an error message is
constructed that shows the differences in the dictionaries. This
method will be used by default to compare dictionaries in
calls to <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p id="other-methods-and-attrs">Finally the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> provides the following methods and attributes:</p>
<dl class="method">
<dt id="unittest.TestCase.fail">
<tt class="descname">fail</tt><big>(</big><em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.fail" title="Permalink to this definition">¶</a></dt>
<dd><p>Signals a test failure unconditionally, with <em>msg</em> or <tt class="xref docutils literal"><span class="pre">None</span></tt> for
the error message.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.failureException">
<tt class="descname">failureException</tt><a class="headerlink" href="#unittest.TestCase.failureException" title="Permalink to this definition">¶</a></dt>
<dd><p>This class attribute gives the exception raised by the test method.  If a
test framework needs to use a specialized exception, possibly to carry
additional information, it must subclass this exception in order to &#8220;play
fair&#8221; with the framework.  The initial value of this attribute is
<a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.longMessage">
<tt class="descname">longMessage</tt><a class="headerlink" href="#unittest.TestCase.longMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>If set to <tt class="xref docutils literal"><span class="pre">True</span></tt> then any explicit failure message you pass in to the
<a class="reference internal" href="#assert-methods"><em>assert methods</em></a> will be appended to the end of the
normal failure message.  The normal messages contain useful information
about the objects involved, for example the message from assertEqual
shows you the repr of the two unequal objects. Setting this attribute
to <tt class="xref docutils literal"><span class="pre">True</span></tt> allows you to have a custom error message in addition to the
normal one.</p>
<p>This attribute defaults to <tt class="xref docutils literal"><span class="pre">False</span></tt>, meaning that a custom message passed
to an assert method will silence the normal message.</p>
<p>The class setting can be overridden in individual tests by assigning an
instance attribute to <tt class="xref docutils literal"><span class="pre">True</span></tt> or <tt class="xref docutils literal"><span class="pre">False</span></tt> before calling the assert methods.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.maxDiff">
<tt class="descname">maxDiff</tt><a class="headerlink" href="#unittest.TestCase.maxDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute controls the maximum length of diffs output by assert
methods that report diffs on failure. It defaults to 80*8 characters.
Assert methods affected by this attribute are
<a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual()</span></tt></a> (including all the sequence comparison
methods that delegate to it), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictEqual()</span></tt></a> and
<a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual()</span></tt></a>.</p>
<p>Setting <tt class="docutils literal"><span class="pre">maxDiff</span></tt> to None means that there is no maximum length of
diffs.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p>Testing frameworks can use the following methods to collect information on
the test:</p>
<dl class="method">
<dt id="unittest.TestCase.countTestCases">
<tt class="descname">countTestCases</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.countTestCases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of tests represented by this test object.  For
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances, this will always be <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.defaultTestResult">
<tt class="descname">defaultTestResult</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of the test result class that should be used for this
test case class (if no other result instance is provided to the
<a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method).</p>
<p>For <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances, this will always be an instance of
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a>; subclasses of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> should override this
as necessary.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.id">
<tt class="descname">id</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string identifying the specific test case.  This is usually the
full name of the test method, including the module and class name.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.shortDescription">
<tt class="descname">shortDescription</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.shortDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a description of the test, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if no description
has been provided.  The default implementation of this method
returns the first line of the test method&#8217;s docstring, if available,
or <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const xref docutils literal"><span class="pre">None</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.addCleanup">
<tt class="descname">addCleanup</tt><big>(</big><em>function</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#unittest.TestCase.addCleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a function to be called after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> to cleanup resources
used during the test. Functions will be called in reverse order to the
order they are added (LIFO). They are called with any arguments and
keyword arguments passed into <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><tt class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></tt></a> when they are
added.</p>
<p>If <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> fails, meaning that <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> is not called,
then any cleanup functions added will still be called.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.doCleanups">
<tt class="descname">doCleanups</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.doCleanups" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called unconditionally after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a>, or
after <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> if <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> raises an exception.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><tt class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></tt></a>. If you need cleanup functions to be called
<em>prior</em> to <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> then you can call <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><tt class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></tt></a>
yourself.</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><tt class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></tt></a> pops methods off the stack of cleanup
functions one at a time, so it can be called at any time.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">FunctionTestCase</tt><big>(</big><em>testFunc</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#unittest.FunctionTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements the portion of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> interface which
allows the test runner to drive the test, but does not provide the methods
which test code can use to check and report errors.  This is used to create
test cases using legacy test code, allowing it to be integrated into a
<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a>-based test framework.</p>
</dd></dl>

<div class="section" id="deprecated-aliases">
<h4>25.3.7.1.1. Deprecated aliases<a class="headerlink" href="#deprecated-aliases" title="Permalink to this headline">¶</a></h4>
<p>For historical reasons, some of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> methods had one or more
aliases that are now deprecated.  The following table lists the correct names
along with their deprecated aliases:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Method Name</th>
<th class="head">Deprecated alias(es)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a></td>
<td>failUnlessEqual, assertEquals</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotEqual()</span></tt></a></td>
<td>failIfEqual</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></tt></a></td>
<td>failUnless, assert_</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><tt class="xref py py-meth docutils literal"><span class="pre">assertFalse()</span></tt></a></td>
<td>failIf</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a></td>
<td>failUnlessRaises</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></tt></a></td>
<td>failUnlessAlmostEqual</td>
</tr>
<tr><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></tt></a></td>
<td>failIfAlmostEqual</td>
</tr>
</tbody>
</table>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 2.7: </span>the aliases listed in the second column</p>
</div></blockquote>
</div>
</div>
<div class="section" id="grouping-tests">
<span id="testsuite-objects"></span><h3>25.3.7.2. Grouping tests<a class="headerlink" href="#grouping-tests" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="unittest.TestSuite">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestSuite</tt><big>(</big><em>tests=()</em><big>)</big><a class="headerlink" href="#unittest.TestSuite" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents an aggregation of individual tests cases and test suites.
The class presents the interface needed by the test runner to allow it to be run
as any other test case.  Running a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> instance is the same as
iterating over the suite, running each test individually.</p>
<p>If <em>tests</em> is given, it must be an iterable of individual test cases or other
test suites that will be used to build the suite initially. Additional methods
are provided to add test cases and suites to the collection later on.</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> objects behave much like <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> objects, except
they do not actually implement a test.  Instead, they are used to aggregate
tests into groups of tests that should be run together. Some additional
methods are available to add tests to <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> instances:</p>
<dl class="method">
<dt id="unittest.TestSuite.addTest">
<tt class="descname">addTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.addTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> to the suite.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.addTests">
<tt class="descname">addTests</tt><big>(</big><em>tests</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.addTests" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all the tests from an iterable of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>
instances to this test suite.</p>
<p>This is equivalent to iterating over <em>tests</em>, calling <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><tt class="xref py py-meth docutils literal"><span class="pre">addTest()</span></tt></a> for
each element.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> shares the following methods with <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>:</p>
<dl class="method">
<dt id="unittest.TestSuite.run">
<tt class="descname">run</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the tests associated with this suite, collecting the result into the
test result object passed as <em>result</em>.  Note that unlike
<a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">TestCase.run()</span></tt></a>, <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><tt class="xref py py-meth docutils literal"><span class="pre">TestSuite.run()</span></tt></a> requires the result object to
be passed in.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.debug">
<tt class="descname">debug</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the tests associated with this suite without collecting the
result. This allows exceptions raised by the test to be propagated to the
caller and can be used to support running tests under a debugger.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.countTestCases">
<tt class="descname">countTestCases</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of tests represented by this test object, including all
individual tests and sub-suites.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests grouped by a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> are always accessed by iteration.
Subclasses can lazily provide tests by overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a>. Note
that this method maybe called several times on a single suite
(for example when counting tests or comparing for equality)
so the tests returned must be the same for repeated iterations.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>In earlier versions the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> accessed tests directly rather
than through iteration, so overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> wasn&#8217;t sufficient
for providing tests.</p>
</dd></dl>

<p>In the typical usage of a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> object, the <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method
is invoked by a <tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt> rather than by the end-user test harness.</p>
</dd></dl>

</div>
<div class="section" id="loading-and-running-tests">
<h3>25.3.7.3. Loading and running tests<a class="headerlink" href="#loading-and-running-tests" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="unittest.TestLoader">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestLoader</tt><a class="headerlink" href="#unittest.TestLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> class is used to create test suites from classes and
modules.  Normally, there is no need to create an instance of this class; the
<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> module provides an instance that can be shared as
<a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><tt class="xref py py-data docutils literal"><span class="pre">unittest.defaultTestLoader</span></tt></a>.  Using a subclass or instance, however,
allows customization of some configurable properties.</p>
<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> objects have the following methods:</p>
<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<tt class="descname">loadTestsFromTestCase</tt><big>(</big><em>testCaseClass</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a suite of all tests cases contained in the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>-derived
<tt class="xref py py-class docutils literal"><span class="pre">testCaseClass</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<tt class="descname">loadTestsFromModule</tt><big>(</big><em>module</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a suite of all tests cases contained in the given module. This
method searches <em>module</em> for classes derived from <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> and
creates an instance of the class for each test method defined for the
class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While using a hierarchy of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>-derived classes can be
convenient in sharing fixtures and helper functions, defining test
methods on base classes that are not intended to be instantiated
directly does not play well with this method.  Doing so, however, can
be useful when the fixtures are different and defined in subclasses.</p>
</div>
<p>If a module provides a <tt class="docutils literal"><span class="pre">load_tests</span></tt> function it will be called to
load the tests. This allows modules to customize test loading.
This is the <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>Support for <tt class="docutils literal"><span class="pre">load_tests</span></tt> added.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromName">
<tt class="descname">loadTestsFromName</tt><big>(</big><em>name</em>, <em>module=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a suite of all tests cases given a string specifier.</p>
<p>The specifier <em>name</em> is a &#8220;dotted name&#8221; that may resolve either to a
module, a test case class, a test method within a test case class, a
<a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> instance, or a callable object which returns a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> instance.  These checks are
applied in the order listed here; that is, a method on a possible test
case class will be picked up as &#8220;a test method within a test case class&#8221;,
rather than &#8220;a callable object&#8221;.</p>
<p>For example, if you have a module <tt class="xref py py-mod docutils literal"><span class="pre">SampleTests</span></tt> containing a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>-derived class <tt class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></tt> with three test
methods (<tt class="xref py py-meth docutils literal"><span class="pre">test_one()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">test_two()</span></tt>, and <tt class="xref py py-meth docutils literal"><span class="pre">test_three()</span></tt>), the
specifier <tt class="docutils literal"><span class="pre">'SampleTests.SampleTestCase'</span></tt> would cause this method to
return a suite which will run all three test methods. Using the specifier
<tt class="docutils literal"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></tt> would cause it to return a test
suite which will run only the <tt class="xref py py-meth docutils literal"><span class="pre">test_two()</span></tt> test method. The specifier
can refer to modules and packages which have not been imported; they will
be imported as a side-effect.</p>
<p>The method optionally resolves <em>name</em> relative to the given <em>module</em>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<tt class="descname">loadTestsFromNames</tt><big>(</big><em>names</em>, <em>module=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFromName()</span></tt></a>, but takes a sequence of names rather
than a single name.  The return value is a test suite which supports all
the tests defined for each name.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.getTestCaseNames">
<tt class="descname">getTestCaseNames</tt><big>(</big><em>testCaseClass</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted sequence of method names found within <em>testCaseClass</em>;
this should be a subclass of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.discover">
<tt class="descname">discover</tt><big>(</big><em>start_dir</em>, <em>pattern='test*.py'</em>, <em>top_level_dir=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.discover" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return all test modules from the specified start directory,
recursing into subdirectories to find them. Only test files that match
<em>pattern</em> will be loaded. (Using shell style pattern matching.) Only
module names that are importable (i.e. are valid Python identifiers) will
be loaded.</p>
<p>All test modules must be importable from the top level of the project. If
the start directory is not the top level directory then the top level
directory must be specified separately.</p>
<p>If importing a module fails, for example due to a syntax error, then this
will be recorded as a single error and discovery will continue.</p>
<p>If a test package name (directory with <tt class="file docutils literal"><span class="pre">__init__.py</span></tt>) matches the
pattern then the package will be checked for a <tt class="docutils literal"><span class="pre">load_tests</span></tt>
function. If this exists then it will be called with <em>loader</em>, <em>tests</em>,
<em>pattern</em>.</p>
<p>If load_tests exists then discovery does <em>not</em> recurse into the package,
<tt class="docutils literal"><span class="pre">load_tests</span></tt> is responsible for loading all tests in the package.</p>
<p>The pattern is deliberately not stored as a loader attribute so that
packages can continue discovery themselves. <em>top_level_dir</em> is stored so
<tt class="docutils literal"><span class="pre">load_tests</span></tt> does not need to pass this argument in to
<tt class="docutils literal"><span class="pre">loader.discover()</span></tt>.</p>
<p><em>start_dir</em> can be a dotted module name as well as a directory.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<p>The following attributes of a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> can be configured either by
subclassing or assignment on an instance:</p>
<dl class="attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<tt class="descname">testMethodPrefix</tt><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="Permalink to this definition">¶</a></dt>
<dd><p>String giving the prefix of method names which will be interpreted as test
methods.  The default value is <tt class="docutils literal"><span class="pre">'test'</span></tt>.</p>
<p>This affects <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><tt class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></tt></a> and all the <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt>
methods.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<tt class="descname">sortTestMethodsUsing</tt><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to be used to compare method names when sorting them in
<a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><tt class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></tt></a> and all the <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt> methods. The
default value is the built-in <a class="reference internal" href="functions.html#cmp" title="cmp"><tt class="xref py py-func docutils literal"><span class="pre">cmp()</span></tt></a> function; the attribute can also
be set to <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const xref docutils literal"><span class="pre">None</span></tt></a> to disable the sort.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.suiteClass">
<tt class="descname">suiteClass</tt><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable object that constructs a test suite from a list of tests. No
methods on the resulting object are needed.  The default value is the
<a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> class.</p>
<p>This affects all the <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt> methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TestResult">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestResult</tt><a class="headerlink" href="#unittest.TestResult" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to compile information about which tests have succeeded
and which have failed.</p>
<p>A <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> object stores the results of a set of tests.  The
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> classes ensure that results are
properly recorded; test authors do not need to worry about recording the
outcome of tests.</p>
<p>Testing frameworks built on top of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> may want access to the
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> object generated by running a set of tests for reporting
purposes; a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> instance is returned by the
<tt class="xref py py-meth docutils literal"><span class="pre">TestRunner.run()</span></tt> method for this purpose.</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> instances have the following attributes that will be of
interest when inspecting the results of running a set of tests:</p>
<dl class="attribute">
<dt id="unittest.TestResult.errors">
<tt class="descname">errors</tt><a class="headerlink" href="#unittest.TestResult.errors" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances and strings
holding formatted tracebacks. Each tuple represents a test which raised an
unexpected exception.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.2: </span>Contains formatted tracebacks instead of <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> results.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failures">
<tt class="descname">failures</tt><a class="headerlink" href="#unittest.TestResult.failures" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances and strings
holding formatted tracebacks. Each tuple represents a test where a failure
was explicitly signalled using the <tt class="xref py py-meth docutils literal"><span class="pre">TestCase.fail*()</span></tt> or
<tt class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></tt> methods.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.2: </span>Contains formatted tracebacks instead of <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> results.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.skipped">
<tt class="descname">skipped</tt><a class="headerlink" href="#unittest.TestResult.skipped" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances and strings
holding the reason for skipping the test.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.expectedFailures">
<tt class="descname">expectedFailures</tt><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances and strings
holding formatted tracebacks.  Each tuple represents an expected failure
of the test case.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<tt class="descname">unexpectedSuccesses</tt><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> instances that were marked as expected
failures, but succeeded.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.shouldStop">
<tt class="descname">shouldStop</tt><a class="headerlink" href="#unittest.TestResult.shouldStop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set to <tt class="xref docutils literal"><span class="pre">True</span></tt> when the execution of tests should stop by <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.testsRun">
<tt class="descname">testsRun</tt><a class="headerlink" href="#unittest.TestResult.testsRun" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of tests run so far.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.buffer">
<tt class="descname">buffer</tt><a class="headerlink" href="#unittest.TestResult.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>If set to true, <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> and <tt class="docutils literal"><span class="pre">sys.stderr</span></tt> will be buffered in between
<a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><tt class="xref py py-meth docutils literal"><span class="pre">startTest()</span></tt></a> and <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><tt class="xref py py-meth docutils literal"><span class="pre">stopTest()</span></tt></a> being called. Collected output will
only be echoed onto the real <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> and <tt class="docutils literal"><span class="pre">sys.stderr</span></tt> if the test
fails or errors. Any output is also attached to the failure / error message.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failfast">
<tt class="descname">failfast</tt><a class="headerlink" href="#unittest.TestResult.failfast" title="Permalink to this definition">¶</a></dt>
<dd><p>If set to true <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> will be called on the first failure or error,
halting the test run.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.wasSuccessful">
<tt class="descname">wasSuccessful</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="xref docutils literal"><span class="pre">True</span></tt> if all tests run so far have passed, otherwise returns
<tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestResult.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be called to signal that the set of tests being run should
be aborted by setting the <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><tt class="xref py py-attr docutils literal"><span class="pre">shouldStop</span></tt></a> attribute to <tt class="xref docutils literal"><span class="pre">True</span></tt>.
<tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt> objects should respect this flag and return without
running any additional tests.</p>
<p>For example, this feature is used by the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><tt class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></tt></a> class to
stop the test framework when the user signals an interrupt from the
keyboard.  Interactive tools which provide <tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt>
implementations can use this in a similar manner.</p>
</dd></dl>

<p>The following methods of the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> class are used to maintain
the internal data structures, and may be extended in subclasses to support
additional reporting requirements.  This is particularly useful in building
tools which support interactive reporting while tests are being run.</p>
<dl class="method">
<dt id="unittest.TestResult.startTest">
<tt class="descname">startTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.startTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> is about to be run.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTest">
<tt class="descname">stopTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.stopTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after the test case <em>test</em> has been executed, regardless of the
outcome.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.startTestRun">
<tt class="descname">startTestRun</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.startTestRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Called once before any tests are executed.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTestRun">
<tt class="descname">stopTestRun</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Called once after all tests are executed.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addError">
<tt class="descname">addError</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addError" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> raises an unexpected exception <em>err</em> is a
tuple of the form returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a>: <tt class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span>
<span class="pre">traceback)</span></tt>.</p>
<p>The default implementation appends a tuple <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> to
the instance&#8217;s <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><tt class="xref py py-attr docutils literal"><span class="pre">errors</span></tt></a> attribute, where <em>formatted_err</em> is a
formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addFailure">
<tt class="descname">addFailure</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> signals a failure. <em>err</em> is a tuple of
the form returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a>: <tt class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></tt>.</p>
<p>The default implementation appends a tuple <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> to
the instance&#8217;s <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><tt class="xref py py-attr docutils literal"><span class="pre">failures</span></tt></a> attribute, where <em>formatted_err</em> is a
formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSuccess">
<tt class="descname">addSuccess</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addSuccess" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> succeeds.</p>
<p>The default implementation does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSkip">
<tt class="descname">addSkip</tt><big>(</big><em>test</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addSkip" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> is skipped.  <em>reason</em> is the reason the
test gave for skipping.</p>
<p>The default implementation appends a tuple <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">reason)</span></tt> to the
instance&#8217;s <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><tt class="xref py py-attr docutils literal"><span class="pre">skipped</span></tt></a> attribute.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addExpectedFailure">
<tt class="descname">addExpectedFailure</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> fails, but was marked with the
<a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> decorator.</p>
<p>The default implementation appends a tuple <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> to
the instance&#8217;s <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><tt class="xref py py-attr docutils literal"><span class="pre">expectedFailures</span></tt></a> attribute, where <em>formatted_err</em>
is a formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<tt class="descname">addUnexpectedSuccess</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the test case <em>test</em> was marked with the
<a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> decorator, but succeeded.</p>
<p>The default implementation appends the test to the instance&#8217;s
<a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><tt class="xref py py-attr docutils literal"><span class="pre">unexpectedSuccesses</span></tt></a> attribute.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TextTestResult">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TextTestResult</tt><big>(</big><em>stream</em>, <em>descriptions</em>, <em>verbosity</em><big>)</big><a class="headerlink" href="#unittest.TextTestResult" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> used by the
<a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><tt class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7: </span>This class was previously named <tt class="docutils literal"><span class="pre">_TextTestResult</span></tt>. The old name still
exists as an alias but is deprecated.</p>
</dd></dl>

<dl class="data">
<dt id="unittest.defaultTestLoader">
<tt class="descclassname">unittest.</tt><tt class="descname">defaultTestLoader</tt><a class="headerlink" href="#unittest.defaultTestLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> class intended to be shared.  If no
customization of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> is needed, this instance can be used
instead of repeatedly creating new instances.</p>
</dd></dl>

<dl class="class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TextTestRunner</tt><big>(</big><em>stream=sys.stderr</em>, <em>descriptions=True</em>, <em>verbosity=1</em><big>)</big><a class="headerlink" href="#unittest.TextTestRunner" title="Permalink to this definition">¶</a></dt>
<dd><p>A basic test runner implementation which prints results on standard error.  It
has a few configurable parameters, but is essentially very simple.  Graphical
applications which run test suites should provide alternate implementations.</p>
<dl class="method">
<dt id="unittest.TextTestRunner._makeResult">
<tt class="descname">_makeResult</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the instance of <tt class="docutils literal"><span class="pre">TestResult</span></tt> used by <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt>.
It is not intended to be called directly, but can be overridden in
subclasses to provide a custom <tt class="docutils literal"><span class="pre">TestResult</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">_makeResult()</span></tt> instantiates the class or callable passed in the
<tt class="docutils literal"><span class="pre">TextTestRunner</span></tt> constructor as the <tt class="docutils literal"><span class="pre">resultclass</span></tt> argument. It
defaults to <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><tt class="xref py py-class docutils literal"><span class="pre">TextTestResult</span></tt></a> if no <tt class="docutils literal"><span class="pre">resultclass</span></tt> is provided.
The result class is instantiated with the following arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="unittest.main">
<tt class="descclassname">unittest.</tt><tt class="descname">main</tt><big>(</big><span class="optional">[</span><em>module</em><span class="optional">[</span>, <em>defaultTest</em><span class="optional">[</span>, <em>argv</em><span class="optional">[</span>, <em>testRunner</em><span class="optional">[</span>, <em>testLoader</em><span class="optional">[</span>, <em>exit</em><span class="optional">[</span>, <em>verbosity</em><span class="optional">[</span>, <em>failfast</em><span class="optional">[</span>, <em>catchbreak</em><span class="optional">[</span>, <em>buffer</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#unittest.main" title="Permalink to this definition">¶</a></dt>
<dd><p>A command-line program that loads a set of tests from <em>module</em> and runs them;
this is primarily for making test modules conveniently executable.
The simplest use for this function is to include the following line at the
end of a test script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>You can run tests with more detailed information by passing in the verbosity
argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>argv</em> argument can be a list of options passed to the program, with the
first element being the program name.  If not specified or <tt class="xref docutils literal"><span class="pre">None</span></tt>,
the values of <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><tt class="xref py py-data docutils literal"><span class="pre">sys.argv</span></tt></a> are used.</p>
<p>The <em>testRunner</em> argument can either be a test runner class or an already
created instance of it. By default <tt class="docutils literal"><span class="pre">main</span></tt> calls <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt></a> with
an exit code indicating success or failure of the tests run.</p>
<p>The <em>testLoader</em> argument has to be a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> instance,
and defaults to <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><tt class="xref py py-data docutils literal"><span class="pre">defaultTestLoader</span></tt></a>.</p>
<p><tt class="docutils literal"><span class="pre">main</span></tt> supports being used from the interactive interpreter by passing in the
argument <tt class="docutils literal"><span class="pre">exit=False</span></tt>. This displays the result on standard output without
calling <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s">&#39;test_module&#39;</span><span class="p">,</span> <span class="nb">exit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>failfast</em>, <em>catchbreak</em> and <em>buffer</em> parameters have the same
effect as the same-name <a class="reference internal" href="#command-line-options">command-line options</a>.</p>
<p>Calling <tt class="docutils literal"><span class="pre">main</span></tt> actually returns an instance of the <tt class="docutils literal"><span class="pre">TestProgram</span></tt> class.
This stores the result of the tests run as the <tt class="docutils literal"><span class="pre">result</span></tt> attribute.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>The <em>exit</em>, <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em> and <em>buffer</em>
parameters were added.</p>
</dd></dl>

<div class="section" id="load-tests-protocol">
<h4>25.3.7.3.1. load_tests Protocol<a class="headerlink" href="#load-tests-protocol" title="Permalink to this headline">¶</a></h4>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
<p>Modules or packages can customize how tests are loaded from them during normal
test runs or test discovery by implementing a function called <tt class="docutils literal"><span class="pre">load_tests</span></tt>.</p>
<p>If a test module defines <tt class="docutils literal"><span class="pre">load_tests</span></tt> it will be called by
<a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><tt class="xref py py-meth docutils literal"><span class="pre">TestLoader.loadTestsFromModule()</span></tt></a> with the following arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>It should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>.</p>
<p><em>loader</em> is the instance of <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> doing the loading.
<em>standard_tests</em> are the tests that would be loaded by default from the
module. It is common for test modules to only want to add or remove tests
from the standard set of tests.
The third argument is used when loading packages as part of test discovery.</p>
<p>A typical <tt class="docutils literal"><span class="pre">load_tests</span></tt> function that loads tests from a specific set of
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> classes may look like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>If discovery is started, either from the command line or by calling
<a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><tt class="xref py py-meth docutils literal"><span class="pre">TestLoader.discover()</span></tt></a>, with a pattern that matches a package
name then the package <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> will be checked for <tt class="docutils literal"><span class="pre">load_tests</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default pattern is <tt class="docutils literal"><span class="pre">'test*.py'</span></tt>. This matches all Python files
that start with <tt class="docutils literal"><span class="pre">'test'</span></tt> but <em>won&#8217;t</em> match any test directories.</p>
<p class="last">A pattern like <tt class="docutils literal"><span class="pre">'test*'</span></tt> will match test packages as well as
modules.</p>
</div>
<p>If the package <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> defines <tt class="docutils literal"><span class="pre">load_tests</span></tt> then it will be
called and discovery not continued into the package. <tt class="docutils literal"><span class="pre">load_tests</span></tt>
is called with the following arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>This should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> representing all the tests
from the package. (<tt class="docutils literal"><span class="pre">standard_tests</span></tt> will only contain tests
collected from <tt class="file docutils literal"><span class="pre">__init__.py</span></tt>.)</p>
<p>Because the pattern is passed into <tt class="docutils literal"><span class="pre">load_tests</span></tt> the package is free to
continue (and potentially modify) test discovery. A &#8216;do nothing&#8217;
<tt class="docutils literal"><span class="pre">load_tests</span></tt> function for a test package would look like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="class-and-module-fixtures">
<h2>25.3.8. Class and Module Fixtures<a class="headerlink" href="#class-and-module-fixtures" title="Permalink to this headline">¶</a></h2>
<p>Class and module level fixtures are implemented in <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>. When
the test suite encounters a test from a new class then <tt class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></tt>
from the previous class (if there is one) is called, followed by
<tt class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></tt> from the new class.</p>
<p>Similarly if a test is from a different module from the previous test then
<tt class="docutils literal"><span class="pre">tearDownModule</span></tt> from the previous module is run, followed by
<tt class="docutils literal"><span class="pre">setUpModule</span></tt> from the new module.</p>
<p>After all the tests have run the final <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> and
<tt class="docutils literal"><span class="pre">tearDownModule</span></tt> are run.</p>
<p>Note that shared fixtures do not play well with [potential] features like test
parallelization and they break test isolation. They should be used with care.</p>
<p>The default ordering of tests created by the unittest test loaders is to group
all tests from the same modules and classes together. This will lead to
<tt class="docutils literal"><span class="pre">setUpClass</span></tt> / <tt class="docutils literal"><span class="pre">setUpModule</span></tt> (etc) being called exactly once per class and
module. If you randomize the order, so that tests from different modules and
classes are adjacent to each other, then these shared fixture functions may be
called multiple times in a single test run.</p>
<p>Shared fixtures are not intended to work with suites with non-standard
ordering. A <tt class="docutils literal"><span class="pre">BaseTestSuite</span></tt> still exists for frameworks that don&#8217;t want to
support shared fixtures.</p>
<p>If there are any exceptions raised during one of the shared fixture functions
the test is reported as an error. Because there is no corresponding test
instance an <tt class="docutils literal"><span class="pre">_ErrorHolder</span></tt> object (that has the same interface as a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a>) is created to represent the error. If you are just using
the standard unittest test runner then this detail doesn&#8217;t matter, but if you
are a framework author it may be relevant.</p>
<div class="section" id="setupclass-and-teardownclass">
<h3>25.3.8.1. setUpClass and tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="Permalink to this headline">¶</a></h3>
<p>These must be implemented as class methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>If you want the <tt class="docutils literal"><span class="pre">setUpClass</span></tt> and <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> on base classes called
then you must call up to them yourself. The implementations in
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> are empty.</p>
<p>If an exception is raised during a <tt class="docutils literal"><span class="pre">setUpClass</span></tt> then the tests in the class
are not run and the <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> is not run. Skipped classes will not
have <tt class="docutils literal"><span class="pre">setUpClass</span></tt> or <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> run. If the exception is a
<tt class="docutils literal"><span class="pre">SkipTest</span></tt> exception then the class will be reported as having been skipped
instead of as an error.</p>
</div>
<div class="section" id="setupmodule-and-teardownmodule">
<h3>25.3.8.2. setUpModule and tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="Permalink to this headline">¶</a></h3>
<p>These should be implemented as functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>If an exception is raised in a <tt class="docutils literal"><span class="pre">setUpModule</span></tt> then none of the tests in the
module will be run and the <tt class="docutils literal"><span class="pre">tearDownModule</span></tt> will not be run. If the exception is a
<tt class="docutils literal"><span class="pre">SkipTest</span></tt> exception then the module will be reported as having been skipped
instead of as an error.</p>
</div>
</div>
<div class="section" id="signal-handling">
<h2>25.3.9. Signal Handling<a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#cmdoption-unittest-c"><em class="xref std std-option">-c/--catch</em></a> command-line option to unittest,
along with the <tt class="docutils literal"><span class="pre">catchbreak</span></tt> parameter to <a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a>, provide
more friendly handling of control-C during a test run. With catch break
behavior enabled control-C will allow the currently running test to complete,
and the test run will then end and report all the results so far. A second
control-c will raise a <a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><tt class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a> in the usual way.</p>
<p>The control-c handling signal handler attempts to remain compatible with code or
tests that install their own <tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt> handler. If the <tt class="docutils literal"><span class="pre">unittest</span></tt>
handler is called but <em>isn&#8217;t</em> the installed <tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt> handler,
i.e. it has been replaced by the system under test and delegated to, then it
calls the default handler. This will normally be the expected behavior by code
that replaces an installed handler and delegates to it. For individual tests
that need <tt class="docutils literal"><span class="pre">unittest</span></tt> control-c handling disabled the <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><tt class="xref py py-func docutils literal"><span class="pre">removeHandler()</span></tt></a>
decorator can be used.</p>
<p>There are a few utility functions for framework authors to enable control-c
handling functionality within test frameworks.</p>
<dl class="function">
<dt id="unittest.installHandler">
<tt class="descclassname">unittest.</tt><tt class="descname">installHandler</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.installHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Install the control-c handler. When a <tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt> is received
(usually in response to the user pressing control-c) all registered results
have <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> called.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.registerResult">
<tt class="descclassname">unittest.</tt><tt class="descname">registerResult</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.registerResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> object for control-c handling. Registering a
result stores a weak reference to it, so it doesn&#8217;t prevent the result from
being garbage collected.</p>
<p>Registering a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> object has no side-effects if control-c
handling is not enabled, so test frameworks can unconditionally register
all results they create independently of whether or not handling is enabled.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeResult">
<tt class="descclassname">unittest.</tt><tt class="descname">removeResult</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.removeResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a registered result. Once a result has been removed then
<a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> will no longer be called on that result object in
response to a control-c.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeHandler">
<tt class="descclassname">unittest.</tt><tt class="descname">removeHandler</tt><big>(</big><em>function=None</em><big>)</big><a class="headerlink" href="#unittest.removeHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>When called without arguments this function removes the control-c handler
if it has been installed. This function can also be used as a test decorator
to temporarily remove the handler whilst the test is being executed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@unittest.removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">25.3. <tt class="docutils literal"><span class="pre">unittest</span></tt> &#8212; Unit testing framework</a><ul>
<li><a class="reference internal" href="#basic-example">25.3.1. Basic example</a></li>
<li><a class="reference internal" href="#command-line-interface">25.3.2. Command-Line Interface</a><ul>
<li><a class="reference internal" href="#command-line-options">25.3.2.1. Command-line options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">25.3.3. Test Discovery</a></li>
<li><a class="reference internal" href="#organizing-test-code">25.3.4. Organizing test code</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">25.3.5. Re-using old test code</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">25.3.6. Skipping tests and expected failures</a></li>
<li><a class="reference internal" href="#classes-and-functions">25.3.7. Classes and functions</a><ul>
<li><a class="reference internal" href="#test-cases">25.3.7.1. Test cases</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">25.3.7.1.1. Deprecated aliases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">25.3.7.2. Grouping tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">25.3.7.3. Loading and running tests</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">25.3.7.3.1. load_tests Protocol</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">25.3.8. Class and Module Fixtures</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">25.3.8.1. setUpClass and tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">25.3.8.2. setUpModule and tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">25.3.9. Signal Handling</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="doctest.html"
                        title="previous chapter">25.2. <tt class="docutils literal docutils literal docutils literal"><span class="pre">doctest</span></tt> &#8212; Test interactive Python examples</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="2to3.html"
                        title="next chapter">25.4. 2to3 - Automated Python 2 to 3 code translation</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/unittest.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Automated Python 2 to 3 code translation"
             >next</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — Test interactive Python examples"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="development.html" >25. Development Tools</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2013, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Apr 06, 2013.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>