

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Installing Python Modules &mdash; Python v2.7.4 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v2.7.4 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v2.7.4 documentation" href="../index.html" />
    <link rel="next" title="Python HOWTOs" href="../howto/index.html" />
    <link rel="prev" title="10. API Reference" href="../distutils/apiref.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../howto/index.html" title="Python HOWTOs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="10. API Reference"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="installing-python-modules">
<span id="install-index"></span><h1>Installing Python Modules<a class="headerlink" href="#installing-python-modules" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Greg Ward</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>This document describes the Python Distribution Utilities (&#8220;Distutils&#8221;) from the
end-user&#8217;s point-of-view, describing how to extend the capabilities of a
standard Python installation by building and installing third-party Python
modules and extensions.</p>
</div>
<div class="section" id="introduction">
<span id="inst-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Although Python&#8217;s extensive standard library covers many programming needs,
there often comes a time when you need to add some new functionality to your
Python installation in the form of third-party modules.  This might be necessary
to support your own programming, or to support an application that you want to
use and that happens to be written in Python.</p>
<p>In the past, there has been little support for adding third-party modules to an
existing Python installation.  With the introduction of the Python Distribution
Utilities (Distutils for short) in Python 2.0, this changed.</p>
<p>This document is aimed primarily at the people who need to install third-party
Python modules: end-users and system administrators who just need to get some
Python application running, and existing Python programmers who want to add some
new goodies to their toolbox.  You don&#8217;t need to know Python to read this
document; there will be some brief forays into using Python&#8217;s interactive mode
to explore your installation, but that&#8217;s it.  If you&#8217;re looking for information
on how to distribute your own Python modules so that others may use them, see
the <a class="reference internal" href="../distutils/index.html#distutils-index"><em>Distributing Python Modules</em></a> manual.</p>
<div class="section" id="best-case-trivial-installation">
<span id="inst-trivial-install"></span><h3>Best case: trivial installation<a class="headerlink" href="#best-case-trivial-installation" title="Permalink to this headline">¶</a></h3>
<p>In the best case, someone will have prepared a special version of the module
distribution you want to install that is targeted specifically at your platform
and is installed just like any other software on your platform.  For example,
the module developer might make an executable installer available for Windows
users, an RPM package for users of RPM-based Linux systems (Red Hat, SuSE,
Mandrake, and many others), a Debian package for users of Debian-based Linux
systems, and so forth.</p>
<p>In that case, you would download the installer appropriate to your platform and
do the obvious thing with it: run it if it&#8217;s an executable installer, <tt class="docutils literal"><span class="pre">rpm</span>
<span class="pre">--install</span></tt> it if it&#8217;s an RPM, etc.  You don&#8217;t need to run Python or a setup
script, you don&#8217;t need to compile anything&#8212;you might not even need to read any
instructions (although it&#8217;s always a good idea to do so anyway).</p>
<p>Of course, things will not always be that easy.  You might be interested in a
module distribution that doesn&#8217;t have an easy-to-use installer for your
platform.  In that case, you&#8217;ll have to start with the source distribution
released by the module&#8217;s author/maintainer.  Installing from a source
distribution is not too hard, as long as the modules are packaged in the
standard way.  The bulk of this document is about building and installing
modules from standard source distributions.</p>
</div>
<div class="section" id="the-new-standard-distutils">
<span id="inst-new-standard"></span><h3>The new standard: Distutils<a class="headerlink" href="#the-new-standard-distutils" title="Permalink to this headline">¶</a></h3>
<p>If you download a module source distribution, you can tell pretty quickly if it
was packaged and distributed in the standard way, i.e. using the Distutils.
First, the distribution&#8217;s name and version number will be featured prominently
in the name of the downloaded archive, e.g. <tt class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt> or
<tt class="file docutils literal"><span class="pre">widget-0.9.7.zip</span></tt>.  Next, the archive will unpack into a similarly-named
directory: <tt class="file docutils literal"><span class="pre">foo-1.0</span></tt> or <tt class="file docutils literal"><span class="pre">widget-0.9.7</span></tt>.  Additionally, the
distribution will contain a setup script <tt class="file docutils literal"><span class="pre">setup.py</span></tt>, and a file named
<tt class="file docutils literal"><span class="pre">README.txt</span></tt> or possibly just <tt class="file docutils literal"><span class="pre">README</span></tt>, which should explain that
building and installing the module distribution is a simple matter of running
one command from a terminal:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install
</pre></div>
</div>
<p>For Windows, this command should be run from a command prompt window
(<em class="menuselection">Start ‣ Accessories</em>):</p>
<div class="highlight-none"><div class="highlight"><pre>setup.py install
</pre></div>
</div>
<p>If all these things are true, then you already know how to build and install the
modules you&#8217;ve just downloaded:  Run the command above. Unless you need to
install things in a non-standard way or customize the build process, you don&#8217;t
really need this manual.  Or rather, the above command is everything you need to
get out of this manual.</p>
</div>
</div>
<div class="section" id="standard-build-and-install">
<span id="inst-standard-install"></span><h2>Standard Build and Install<a class="headerlink" href="#standard-build-and-install" title="Permalink to this headline">¶</a></h2>
<p>As described in section <a class="reference internal" href="#inst-new-standard"><em>The new standard: Distutils</em></a>, building and installing a module
distribution using the Distutils is usually one simple command to run from a
terminal:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install
</pre></div>
</div>
<div class="section" id="platform-variations">
<span id="inst-platform-variations"></span><h3>Platform variations<a class="headerlink" href="#platform-variations" title="Permalink to this headline">¶</a></h3>
<p>You should always run the setup command from the distribution root directory,
i.e. the top-level subdirectory that the module source distribution unpacks
into.  For example, if you&#8217;ve just downloaded a module source distribution
<tt class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt> onto a Unix system, the normal thing to do is:</p>
<div class="highlight-none"><div class="highlight"><pre>gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install
</pre></div>
</div>
<p>On Windows, you&#8217;d probably download <tt class="file docutils literal"><span class="pre">foo-1.0.zip</span></tt>.  If you downloaded the
archive file to <tt class="file docutils literal"><span class="pre">C:\Temp</span></tt>, then it would unpack into
<tt class="file docutils literal"><span class="pre">C:\Temp\foo-1.0</span></tt>; you can use either a archive manipulator with a
graphical user interface (such as WinZip) or a command-line tool (such as
<strong class="program">unzip</strong> or <strong class="program">pkunzip</strong>) to unpack the archive.  Then, open a
command prompt window and run:</p>
<div class="highlight-none"><div class="highlight"><pre>cd c:\Temp\foo-1.0
python setup.py install
</pre></div>
</div>
</div>
<div class="section" id="splitting-the-job-up">
<span id="inst-splitting-up"></span><h3>Splitting the job up<a class="headerlink" href="#splitting-the-job-up" title="Permalink to this headline">¶</a></h3>
<p>Running <tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></tt> builds and installs all modules in one run.  If you
prefer to work incrementally&#8212;especially useful if you want to customize the
build process, or if things are going wrong&#8212;you can use the setup script to do
one thing at a time.  This is particularly helpful when the build and install
will be done by different users&#8212;for example, you might want to build a module
distribution and hand it off to a system administrator for installation (or do
it yourself, with super-user privileges).</p>
<p>For example, you can build everything in one step, and then install everything
in a second step, by invoking the setup script twice:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build
python setup.py install
</pre></div>
</div>
<p>If you do this, you will notice that running the <strong class="command">install</strong> command
first runs the <strong class="command">build</strong> command, which&#8212;in this case&#8212;quickly notices
that it has nothing to do, since everything in the <tt class="file docutils literal"><span class="pre">build</span></tt> directory is
up-to-date.</p>
<p>You may not need this ability to break things down often if all you do is
install modules downloaded off the &#8216;net, but it&#8217;s very handy for more advanced
tasks.  If you get into distributing your own Python modules and extensions,
you&#8217;ll run lots of individual Distutils commands on their own.</p>
</div>
<div class="section" id="how-building-works">
<span id="inst-how-build-works"></span><h3>How building works<a class="headerlink" href="#how-building-works" title="Permalink to this headline">¶</a></h3>
<p>As implied above, the <strong class="command">build</strong> command is responsible for putting the
files to install into a <em>build directory</em>.  By default, this is <tt class="file docutils literal"><span class="pre">build</span></tt>
under the distribution root; if you&#8217;re excessively concerned with speed, or want
to keep the source tree pristine, you can change the build directory with the
<em class="xref std std-option">--build-base</em> option. For example:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --build-base=/path/to/pybuild/foo-1.0
</pre></div>
</div>
<p>(Or you could do this permanently with a directive in your system or personal
Distutils configuration file; see section <a class="reference internal" href="#inst-config-files"><em>Distutils Configuration Files</em></a>.)  Normally, this
isn&#8217;t necessary.</p>
<p>The default layout for the build tree is as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>--- build/ --- lib/
or
--- build/ --- lib.&lt;plat&gt;/
               temp.&lt;plat&gt;/
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt> expands to a brief description of the current OS/hardware
platform and Python version.  The first form, with just a <tt class="file docutils literal"><span class="pre">lib</span></tt> directory,
is used for &#8220;pure module distributions&#8221;&#8212;that is, module distributions that
include only pure Python modules.  If a module distribution contains any
extensions (modules written in C/C++), then the second form, with two <tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt>
directories, is used.  In that case, the <tt class="file docutils literal"><span class="pre">temp.</span><em><span class="pre">plat</span></em></tt> directory holds
temporary files generated by the compile/link process that don&#8217;t actually get
installed.  In either case, the <tt class="file docutils literal"><span class="pre">lib</span></tt> (or <tt class="file docutils literal"><span class="pre">lib.</span><em><span class="pre">plat</span></em></tt>) directory
contains all Python modules (pure Python and extensions) that will be installed.</p>
<p>In the future, more directories will be added to handle Python scripts,
documentation, binary executables, and whatever else is needed to handle the job
of installing Python modules and applications.</p>
</div>
<div class="section" id="how-installation-works">
<span id="inst-how-install-works"></span><h3>How installation works<a class="headerlink" href="#how-installation-works" title="Permalink to this headline">¶</a></h3>
<p>After the <strong class="command">build</strong> command runs (whether you run it explicitly, or the
<strong class="command">install</strong> command does it for you), the work of the <strong class="command">install</strong>
command is relatively simple: all it has to do is copy everything under
<tt class="file docutils literal"><span class="pre">build/lib</span></tt> (or <tt class="file docutils literal"><span class="pre">build/lib.</span><em><span class="pre">plat</span></em></tt>) to your chosen installation
directory.</p>
<p>If you don&#8217;t choose an installation directory&#8212;i.e., if you just run <tt class="docutils literal"><span class="pre">setup.py</span>
<span class="pre">install</span></tt>&#8212;then the <strong class="command">install</strong> command installs to the standard
location for third-party Python modules.  This location varies by platform and
by how you built/installed Python itself.  On Unix (and Mac OS X, which is also
Unix-based), it also depends on whether the module distribution being installed
is pure Python or contains extensions (&#8220;non-pure&#8221;):</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="42%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Platform</th>
<th class="head">Standard installation location</th>
<th class="head">Default value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Unix (pure)</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td>(1)</td>
</tr>
<tr><td>Unix (non-pure)</td>
<td><tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td>(1)</td>
</tr>
<tr><td>Windows</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">C:\Python</span><em><span class="pre">XY</span></em><span class="pre">\Lib\site-packages</span></tt></td>
<td>(2)</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>Most Linux distributions include Python as a standard part of the system, so
<tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> and <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> are usually both <tt class="file docutils literal"><span class="pre">/usr</span></tt> on
Linux.  If you build Python yourself on Linux (or any Unix-like system), the
default <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> and <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> are <tt class="file docutils literal"><span class="pre">/usr/local</span></tt>.</li>
<li>The default installation directory on Windows was <tt class="file docutils literal"><span class="pre">C:\Program</span>
<span class="pre">Files\Python</span></tt> under Python 1.6a1, 1.5.2, and earlier.</li>
</ol>
<p><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> and <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> stand for the directories that Python
is installed to, and where it finds its libraries at run-time.  They are always
the same under Windows, and very often the same under Unix and Mac OS X.  You
can find out what your Python installation uses for <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> and
<tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> by running Python in interactive mode and typing a few
simple commands. Under Unix, just type <tt class="docutils literal"><span class="pre">python</span></tt> at the shell prompt.  Under
Windows, choose <em class="menuselection">Start ‣ Programs ‣ Python X.Y ‣
Python (command line)</em>.   Once the interpreter is started, you type Python code
at the prompt.  For example, on my Linux system, I type the three Python
statements shown below, and get the output as shown, to find out my
<tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> and <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt>:</p>
<div class="highlight-none"><div class="highlight"><pre>Python 2.4 (#26, Aug  7 2004, 17:19:02)
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.prefix
&#39;/usr&#39;
&gt;&gt;&gt; sys.exec_prefix
&#39;/usr&#39;
</pre></div>
</div>
<p>A few other placeholders are used in this document: <tt class="file docutils literal"><em><span class="pre">X.Y</span></em></tt> stands for the
version of Python, for example <tt class="docutils literal"><span class="pre">2.7</span></tt>; <tt class="file docutils literal"><em><span class="pre">distname</span></em></tt> will be replaced by
the name of the module distribution being installed.  Dots and capitalization
are important in the paths; for example, a value that uses <tt class="docutils literal"><span class="pre">python2.7</span></tt> on UNIX
will typically use <tt class="docutils literal"><span class="pre">Python27</span></tt> on Windows.</p>
<p>If you don&#8217;t want to install modules to the standard location, or if you don&#8217;t
have permission to write there, then you need to read about alternate
installations in section <a class="reference internal" href="#inst-alt-install"><em>Alternate Installation</em></a>.  If you want to customize your
installation directories more heavily, see section <a class="reference internal" href="#inst-custom-install"><em>Custom Installation</em></a> on
custom installations.</p>
</div>
</div>
<div class="section" id="alternate-installation">
<span id="inst-alt-install"></span><h2>Alternate Installation<a class="headerlink" href="#alternate-installation" title="Permalink to this headline">¶</a></h2>
<p>Often, it is necessary or desirable to install modules to a location other than
the standard location for third-party Python modules.  For example, on a Unix
system you might not have permission to write to the standard third-party module
directory.  Or you might wish to try out a module before making it a standard
part of your local Python installation.  This is especially true when upgrading
a distribution already present: you want to make sure your existing base of
scripts still works with the new version before actually upgrading.</p>
<p>The Distutils <strong class="command">install</strong> command is designed to make installing module
distributions to an alternate location simple and painless.  The basic idea is
that you supply a base directory for the installation, and the
<strong class="command">install</strong> command picks a set of directories (called an <em>installation
scheme</em>) under this base directory in which to install files.  The details
differ across platforms, so read whichever of the following sections applies to
you.</p>
<p>Note that the various alternate installation schemes are mutually exclusive: you
can pass <tt class="docutils literal"><span class="pre">--user</span></tt>, or <tt class="docutils literal"><span class="pre">--home</span></tt>, or <tt class="docutils literal"><span class="pre">--prefix</span></tt> and <tt class="docutils literal"><span class="pre">--exec-prefix</span></tt>, or
<tt class="docutils literal"><span class="pre">--install-base</span></tt> and <tt class="docutils literal"><span class="pre">--install-platbase</span></tt>, but you can&#8217;t mix from these
groups.</p>
<div class="section" id="alternate-installation-the-user-scheme">
<span id="inst-alt-install-user"></span><h3>Alternate installation: the user scheme<a class="headerlink" href="#alternate-installation-the-user-scheme" title="Permalink to this headline">¶</a></h3>
<p>This scheme is designed to be the most convenient solution for users that don&#8217;t
have write permission to the global site-packages directory or don&#8217;t want to
install into it.  It is enabled with a simple option:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --user
</pre></div>
</div>
<p>Files will be installed into subdirectories of <a class="reference internal" href="../library/site.html#site.USER_BASE" title="site.USER_BASE"><tt class="xref py py-data docutils literal"><span class="pre">site.USER_BASE</span></tt></a> (written
as <tt class="file docutils literal"><em><span class="pre">userbase</span></em></tt> hereafter).  This scheme installs pure Python modules and
extension modules in the same location (also known as <a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><tt class="xref py py-data docutils literal"><span class="pre">site.USER_SITE</span></tt></a>).
Here are the values for UNIX, including Mac OS X:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation directory</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>modules</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/bin</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></tt></td>
</tr>
</tbody>
</table>
<p>And here are the values used on Windows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation directory</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>modules</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\site-packages</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Scripts</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\Include\</span><em><span class="pre">distname</span></em></tt></td>
</tr>
</tbody>
</table>
<p>The advantage of using this scheme compared to the other ones described below is
that the user site-packages directory is under normal conditions always included
in <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> (see <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> for more information), which means that
there is no additional step to perform after running the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script
to finalize the installation.</p>
<p>The <strong class="command">build_ext</strong> command also has a <tt class="docutils literal"><span class="pre">--user</span></tt> option to add
<tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/include</span></tt> to the compiler search path for header files and
<tt class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/lib</span></tt> to the compiler search path for libraries as well as to
the runtime search path for shared C libraries (rpath).</p>
</div>
<div class="section" id="alternate-installation-the-home-scheme">
<span id="inst-alt-install-home"></span><h3>Alternate installation: the home scheme<a class="headerlink" href="#alternate-installation-the-home-scheme" title="Permalink to this headline">¶</a></h3>
<p>The idea behind the &#8220;home scheme&#8221; is that you build and maintain a personal
stash of Python modules.  This scheme&#8217;s name is derived from the idea of a
&#8220;home&#8221; directory on Unix, since it&#8217;s not unusual for a Unix user to make their
home directory have a layout similar to <tt class="file docutils literal"><span class="pre">/usr/</span></tt> or <tt class="file docutils literal"><span class="pre">/usr/local/</span></tt>.
This scheme can be used by anyone, regardless of the operating system they
are installing for.</p>
<p>Installing a new module distribution is as simple as</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=&lt;dir&gt;
</pre></div>
</div>
<p>where you can supply any directory you like for the <em class="xref std std-option">--home</em> option.  On
Unix, lazy typists can just type a tilde (<tt class="docutils literal"><span class="pre">~</span></tt>); the <strong class="command">install</strong> command
will expand this to your home directory:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~
</pre></div>
</div>
<p>To make Python find the distributions installed with this scheme, you may have
to <a class="reference internal" href="#inst-search-path"><em>modify Python&#8217;s search path</em></a> or edit
<tt class="xref py py-mod docutils literal"><span class="pre">sitecustomize</span></tt> (see <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a>) to call <a class="reference internal" href="../library/site.html#site.addsitedir" title="site.addsitedir"><tt class="xref py py-func docutils literal"><span class="pre">site.addsitedir()</span></tt></a> or edit
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>.</p>
<p>The <em class="xref std std-option">--home</em> option defines the installation base directory.  Files are
installed to the following directories under the installation base as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation directory</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>modules</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/lib/python</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/bin</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/include/python/</span><em><span class="pre">distname</span></em></tt></td>
</tr>
</tbody>
</table>
<p>(Mentally replace slashes with backslashes if you&#8217;re on Windows.)</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.4: </span>The <em class="xref std std-option">--home</em> option used to be supported only on Unix.</p>
</div>
<div class="section" id="alternate-installation-unix-the-prefix-scheme">
<span id="inst-alt-install-prefix-unix"></span><h3>Alternate installation: Unix (the prefix scheme)<a class="headerlink" href="#alternate-installation-unix-the-prefix-scheme" title="Permalink to this headline">¶</a></h3>
<p>The &#8220;prefix scheme&#8221; is useful when you wish to use one Python installation to
perform the build/install (i.e., to run the setup script), but install modules
into the third-party module directory of a different Python installation (or
something that looks like a different Python installation).  If this sounds a
trifle unusual, it is&#8212;that&#8217;s why the user and home schemes come before.  However,
there are at least two known cases where the prefix scheme will be useful.</p>
<p>First, consider that many Linux distributions put Python in <tt class="file docutils literal"><span class="pre">/usr</span></tt>, rather
than the more traditional <tt class="file docutils literal"><span class="pre">/usr/local</span></tt>.  This is entirely appropriate,
since in those cases Python is part of &#8220;the system&#8221; rather than a local add-on.
However, if you are installing Python modules from source, you probably want
them to go in <tt class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></tt> rather than
<tt class="file docutils literal"><span class="pre">/usr/lib/python2.</span><em><span class="pre">X</span></em></tt>.  This can be done with</p>
<div class="highlight-none"><div class="highlight"><pre>/usr/bin/python setup.py install --prefix=/usr/local
</pre></div>
</div>
<p>Another possibility is a network filesystem where the name used to write to a
remote directory is different from the name used to read it: for example, the
Python interpreter accessed as <tt class="file docutils literal"><span class="pre">/usr/local/bin/python</span></tt> might search for
modules in <tt class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></tt>, but those modules would have to
be installed to, say, <tt class="file docutils literal"><span class="pre">/mnt/</span><em><span class="pre">&#64;server</span></em><span class="pre">/export/lib/python2.</span><em><span class="pre">X</span></em></tt>.  This could
be done with</p>
<div class="highlight-none"><div class="highlight"><pre>/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
</pre></div>
</div>
<p>In either case, the <em class="xref std std-option">--prefix</em> option defines the installation base, and
the <em class="xref std std-option">--exec-prefix</em> option defines the platform-specific installation
base, which is used for platform-specific files.  (Currently, this just means
non-pure module distributions, but could be expanded to C libraries, binary
executables, etc.)  If <em class="xref std std-option">--exec-prefix</em> is not supplied, it defaults to
<em class="xref std std-option">--prefix</em>.  Files are installed as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation directory</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Python modules</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
</tr>
<tr><td>extension modules</td>
<td><tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/bin</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></tt></td>
</tr>
</tbody>
</table>
<p>There is no requirement that <em class="xref std std-option">--prefix</em> or <em class="xref std std-option">--exec-prefix</em>
actually point to an alternate Python installation; if the directories listed
above do not already exist, they are created at installation time.</p>
<p>Incidentally, the real reason the prefix scheme is important is simply that a
standard Unix installation uses the prefix scheme, but with <em class="xref std std-option">--prefix</em>
and <em class="xref std std-option">--exec-prefix</em> supplied by Python itself as <tt class="docutils literal"><span class="pre">sys.prefix</span></tt> and
<tt class="docutils literal"><span class="pre">sys.exec_prefix</span></tt>.  Thus, you might think you&#8217;ll never use the prefix scheme,
but every time you run <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt> without any other options,
you&#8217;re using it.</p>
<p>Note that installing extensions to an alternate Python installation has no
effect on how those extensions are built: in particular, the Python header files
(<tt class="file docutils literal"><span class="pre">Python.h</span></tt> and friends) installed with the Python interpreter used to run
the setup script will be used in compiling extensions.  It is your
responsibility to ensure that the interpreter used to run extensions installed
in this way is compatible with the interpreter used to build them.  The best way
to do this is to ensure that the two interpreters are the same version of Python
(possibly different builds, or possibly copies of the same build).  (Of course,
if your <em class="xref std std-option">--prefix</em> and <em class="xref std std-option">--exec-prefix</em> don&#8217;t even point to an
alternate Python installation, this is immaterial.)</p>
</div>
<div class="section" id="alternate-installation-windows-the-prefix-scheme">
<span id="inst-alt-install-prefix-windows"></span><h3>Alternate installation: Windows (the prefix scheme)<a class="headerlink" href="#alternate-installation-windows-the-prefix-scheme" title="Permalink to this headline">¶</a></h3>
<p>Windows has no concept of a user&#8217;s home directory, and since the standard Python
installation under Windows is simpler than under Unix, the <em class="xref std std-option">--prefix</em>
option has traditionally been used to install additional packages in separate
locations on Windows.</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --prefix=&quot;\Temp\Python&quot;
</pre></div>
</div>
<p>to install modules to the <tt class="file docutils literal"><span class="pre">\Temp\Python</span></tt> directory on the current drive.</p>
<p>The installation base is defined by the <em class="xref std std-option">--prefix</em> option; the
<em class="xref std std-option">--exec-prefix</em> option is not supported under Windows, which means that
pure Python modules and extension modules are installed into the same location.
Files are installed as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation directory</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>modules</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Scripts</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Include\</span><em><span class="pre">distname</span></em></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="custom-installation">
<span id="inst-custom-install"></span><h2>Custom Installation<a class="headerlink" href="#custom-installation" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, the alternate installation schemes described in section
<a class="reference internal" href="#inst-alt-install"><em>Alternate Installation</em></a> just don&#8217;t do what you want.  You might want to tweak just
one or two directories while keeping everything under the same base directory,
or you might want to completely redefine the installation scheme.  In either
case, you&#8217;re creating a <em>custom installation scheme</em>.</p>
<p>To create a custom installation scheme, you start with one of the alternate
schemes and override some of the installation directories used for the various
types of files, using these options:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Python modules</td>
<td><tt class="docutils literal"><span class="pre">--install-purelib</span></tt></td>
</tr>
<tr><td>extension modules</td>
<td><tt class="docutils literal"><span class="pre">--install-platlib</span></tt></td>
</tr>
<tr><td>all modules</td>
<td><tt class="docutils literal"><span class="pre">--install-lib</span></tt></td>
</tr>
<tr><td>scripts</td>
<td><tt class="docutils literal"><span class="pre">--install-scripts</span></tt></td>
</tr>
<tr><td>data</td>
<td><tt class="docutils literal"><span class="pre">--install-data</span></tt></td>
</tr>
<tr><td>C headers</td>
<td><tt class="docutils literal"><span class="pre">--install-headers</span></tt></td>
</tr>
</tbody>
</table>
<p>These override options can be relative, absolute,
or explicitly defined in terms of one of the installation base directories.
(There are two installation base directories, and they are normally the same&#8212;
they only differ when you use the Unix &#8220;prefix scheme&#8221; and supply different
<tt class="docutils literal"><span class="pre">--prefix</span></tt> and <tt class="docutils literal"><span class="pre">--exec-prefix</span></tt> options; using <tt class="docutils literal"><span class="pre">--install-lib</span></tt> will
override values computed or given for <tt class="docutils literal"><span class="pre">--install-purelib</span></tt> and
<tt class="docutils literal"><span class="pre">--install-platlib</span></tt>, and is recommended for schemes that don&#8217;t make a
difference between Python and extension modules.)</p>
<p>For example, say you&#8217;re installing a module distribution to your home directory
under Unix&#8212;but you want scripts to go in <tt class="file docutils literal"><span class="pre">~/scripts</span></tt> rather than
<tt class="file docutils literal"><span class="pre">~/bin</span></tt>. As you might expect, you can override this directory with the
<em class="xref std std-option">--install-scripts</em> option; in this case, it makes most sense to supply
a relative path, which will be interpreted relative to the installation base
directory (your home directory, in this case):</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~ --install-scripts=scripts
</pre></div>
</div>
<p>Another Unix example: suppose your Python installation was built and installed
with a prefix of <tt class="file docutils literal"><span class="pre">/usr/local/python</span></tt>, so under a standard  installation
scripts will wind up in <tt class="file docutils literal"><span class="pre">/usr/local/python/bin</span></tt>.  If you want them in
<tt class="file docutils literal"><span class="pre">/usr/local/bin</span></tt> instead, you would supply this absolute directory for the
<em class="xref std std-option">--install-scripts</em> option:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-scripts=/usr/local/bin
</pre></div>
</div>
<p>(This performs an installation using the &#8220;prefix scheme,&#8221; where the prefix is
whatever your Python interpreter was installed with&#8212; <tt class="file docutils literal"><span class="pre">/usr/local/python</span></tt>
in this case.)</p>
<p>If you maintain Python on Windows, you might want third-party modules to live in
a subdirectory of <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt>, rather than right in <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt>
itself.  This is almost as easy as customizing the script installation directory
&#8212;you just have to remember that there are two types of modules to worry about,
Python and extension modules, which can conveniently be both controlled by one
option:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-lib=Site
</pre></div>
</div>
<p>The specified installation directory is relative to <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt>.  Of
course, you also have to ensure that this directory is in Python&#8217;s module
search path, such as by putting a <tt class="file docutils literal"><span class="pre">.pth</span></tt> file in a site directory (see
<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a>).  See section <a class="reference internal" href="#inst-search-path"><em>Modifying Python&#8217;s Search Path</em></a> to find out how to modify
Python&#8217;s search path.</p>
<p>If you want to define an entire installation scheme, you just have to supply all
of the installation directory options.  The recommended way to do this is to
supply relative paths; for example, if you want to maintain all Python
module-related files under <tt class="file docutils literal"><span class="pre">python</span></tt> in your home directory, and you want a
separate directory for each platform that you use your home directory from, you
might define the following installation scheme:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
</pre></div>
</div>
<p>or, equivalently,</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib=&#39;lib.$PLAT&#39; \
                        --install-scripts=scripts
                        --install-data=data
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">$PLAT</span></tt> is not (necessarily) an environment variable&#8212;it will be expanded by
the Distutils as it parses your command line options, just as it does when
parsing your configuration file(s).</p>
<p>Obviously, specifying the entire installation scheme every time you install a
new module distribution would be very tedious.  Thus, you can put these options
into your Distutils config file (see section <a class="reference internal" href="#inst-config-files"><em>Distutils Configuration Files</em></a>):</p>
<div class="highlight-none"><div class="highlight"><pre>[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data
</pre></div>
</div>
<p>or, equivalently,</p>
<div class="highlight-none"><div class="highlight"><pre>[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data
</pre></div>
</div>
<p>Note that these two are <em>not</em> equivalent if you supply a different installation
base directory when you run the setup script.  For example,</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-base=/tmp
</pre></div>
</div>
<p>would install pure modules to <tt class="file docutils literal"><span class="pre">/tmp/python/lib</span></tt> in the first case, and
to <tt class="file docutils literal"><span class="pre">/tmp/lib</span></tt> in the second case.  (For the second case, you probably
want to supply an installation base of <tt class="file docutils literal"><span class="pre">/tmp/python</span></tt>.)</p>
<p>You probably noticed the use of <tt class="docutils literal"><span class="pre">$HOME</span></tt> and <tt class="docutils literal"><span class="pre">$PLAT</span></tt> in the sample
configuration file input.  These are Distutils configuration variables, which
bear a strong resemblance to environment variables. In fact, you can use
environment variables in config files on platforms that have such a notion but
the Distutils additionally define a few extra variables that may not be in your
environment, such as <tt class="docutils literal"><span class="pre">$PLAT</span></tt>.  (And of course, on systems that don&#8217;t have
environment variables, such as Mac OS 9, the configuration variables supplied by
the Distutils are the only ones you can use.) See section <a class="reference internal" href="#inst-config-files"><em>Distutils Configuration Files</em></a>
for details.</p>
<div class="section" id="modifying-python-s-search-path">
<span id="inst-search-path"></span><h3>Modifying Python&#8217;s Search Path<a class="headerlink" href="#modifying-python-s-search-path" title="Permalink to this headline">¶</a></h3>
<p>When the Python interpreter executes an <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement, it searches
for both Python code and extension modules along a search path.  A default value
for the path is configured into the Python binary when the interpreter is built.
You can determine the path by importing the <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> module and printing the
value of <tt class="docutils literal"><span class="pre">sys.path</span></tt>.</p>
<div class="highlight-none"><div class="highlight"><pre>$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/usr/local/lib/python2.3&#39;, &#39;/usr/local/lib/python2.3/plat-linux2&#39;,
 &#39;/usr/local/lib/python2.3/lib-tk&#39;, &#39;/usr/local/lib/python2.3/lib-dynload&#39;,
 &#39;/usr/local/lib/python2.3/site-packages&#39;]
&gt;&gt;&gt;
</pre></div>
</div>
<p>The null string in <tt class="docutils literal"><span class="pre">sys.path</span></tt> represents the current working directory.</p>
<p>The expected convention for locally installed packages is to put them in the
<tt class="file docutils literal"><em><span class="pre">...</span></em><span class="pre">/site-packages/</span></tt> directory, but you may want to install Python
modules into some arbitrary directory.  For example, your site may have a
convention of keeping all software related to the web server under <tt class="file docutils literal"><span class="pre">/www</span></tt>.
Add-on Python modules might then belong in <tt class="file docutils literal"><span class="pre">/www/python</span></tt>, and in order to
import them, this directory must be added to <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  There are several
different ways to add the directory.</p>
<p>The most convenient way is to add a path configuration file to a directory
that&#8217;s already on Python&#8217;s path, usually to the <tt class="file docutils literal"><span class="pre">.../site-packages/</span></tt>
directory.  Path configuration files have an extension of <tt class="file docutils literal"><span class="pre">.pth</span></tt>, and each
line must contain a single path that will be appended to <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  (Because
the new paths are appended to <tt class="docutils literal"><span class="pre">sys.path</span></tt>, modules in the added directories
will not override standard modules.  This means you can&#8217;t use this mechanism for
installing fixed versions of standard modules.)</p>
<p>Paths can be absolute or relative, in which case they&#8217;re relative to the
directory containing the <tt class="file docutils literal"><span class="pre">.pth</span></tt> file.  See the documentation of
the <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> module for more information.</p>
<p>A slightly less convenient way is to edit the <tt class="file docutils literal"><span class="pre">site.py</span></tt> file in Python&#8217;s
standard library, and modify <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  <tt class="file docutils literal"><span class="pre">site.py</span></tt> is automatically
imported when the Python interpreter is executed, unless the <a class="reference internal" href="../using/cmdline.html#cmdoption-S"><em class="xref std std-option">-S</em></a> switch
is supplied to suppress this behaviour.  So you could simply edit
<tt class="file docutils literal"><span class="pre">site.py</span></tt> and add two lines to it:</p>
<div class="highlight-none"><div class="highlight"><pre>import sys
sys.path.append(&#39;/www/python/&#39;)
</pre></div>
</div>
<p>However, if you reinstall the same major version of Python (perhaps when
upgrading from 2.2 to 2.2.2, for example) <tt class="file docutils literal"><span class="pre">site.py</span></tt> will be overwritten by
the stock version.  You&#8217;d have to remember that it was modified and save a copy
before doing the installation.</p>
<p>There are two environment variables that can modify <tt class="docutils literal"><span class="pre">sys.path</span></tt>.
<span class="target" id="index-0"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> sets an alternate value for the prefix of the Python
installation.  For example, if <span class="target" id="index-1"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> is set to <tt class="docutils literal"><span class="pre">/www/python</span></tt>,
the search path will be set to <tt class="docutils literal"><span class="pre">['',</span> <span class="pre">'/www/python/lib/pythonX.Y/',</span>
<span class="pre">'/www/python/lib/pythonX.Y/plat-linux2',</span> <span class="pre">...]</span></tt>.</p>
<p>The <span class="target" id="index-2"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> variable can be set to a list of paths that will be
added to the beginning of <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  For example, if <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> is
set to <tt class="docutils literal"><span class="pre">/www/python:/opt/py</span></tt>, the search path will begin with
<tt class="docutils literal"><span class="pre">['/www/python',</span> <span class="pre">'/opt/py']</span></tt>.  (Note that directories must exist in order to
be added to <tt class="docutils literal"><span class="pre">sys.path</span></tt>; the <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> module removes paths that don&#8217;t
exist.)</p>
<p>Finally, <tt class="docutils literal"><span class="pre">sys.path</span></tt> is just a regular Python list, so any Python application
can modify it by adding or removing entries.</p>
</div>
</div>
<div class="section" id="distutils-configuration-files">
<span id="inst-config-files"></span><h2>Distutils Configuration Files<a class="headerlink" href="#distutils-configuration-files" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, you can use Distutils configuration files to record personal
or site preferences for any Distutils options.  That is, any option to any
command can be stored in one of two or three (depending on your platform)
configuration files, which will be consulted before the command-line is parsed.
This means that configuration files will override default values, and the
command-line will in turn override configuration files.  Furthermore, if
multiple configuration files apply, values from &#8220;earlier&#8221; files are overridden
by &#8220;later&#8221; files.</p>
<div class="section" id="location-and-names-of-config-files">
<span id="inst-config-filenames"></span><h3>Location and names of config files<a class="headerlink" href="#location-and-names-of-config-files" title="Permalink to this headline">¶</a></h3>
<p>The names and locations of the configuration files vary slightly across
platforms.  On Unix and Mac OS X, the three configuration files (in the order
they are processed) are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="73%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Location and filename</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>system</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">ver</span></em><span class="pre">/distutils/distutils.cfg</span></tt></td>
<td>(1)</td>
</tr>
<tr><td>personal</td>
<td><tt class="file docutils literal"><span class="pre">$HOME/.pydistutils.cfg</span></tt></td>
<td>(2)</td>
</tr>
<tr><td>local</td>
<td><tt class="file docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>And on Windows, the configuration files are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="70%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Location and filename</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>system</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\distutils\distutils.cfg</span></tt></td>
<td>(4)</td>
</tr>
<tr><td>personal</td>
<td><tt class="file docutils literal"><span class="pre">%HOME%\pydistutils.cfg</span></tt></td>
<td>(5)</td>
</tr>
<tr><td>local</td>
<td><tt class="file docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>On all platforms, the &#8220;personal&#8221; file can be temporarily disabled by
passing the <cite>&#8211;no-user-cfg</cite> option.</p>
<p>Notes:</p>
<ol class="arabic simple">
<li>Strictly speaking, the system-wide configuration file lives in the directory
where the Distutils are installed; under Python 1.6 and later on Unix, this is
as shown. For Python 1.5.2, the Distutils will normally be installed to
<tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python1.5/site-packages/distutils</span></tt>, so the system
configuration file should be put there under Python 1.5.2.</li>
<li>On Unix, if the <span class="target" id="index-4"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> environment variable is not defined, the user&#8217;s
home directory will be determined with the <tt class="xref py py-func docutils literal"><span class="pre">getpwuid()</span></tt> function from the
standard <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">pwd</span></tt></a> module. This is done by the <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></tt></a>
function used by Distutils.</li>
<li>I.e., in the current directory (usually the location of the setup script).</li>
<li>(See also note (1).)  Under Python 1.6 and later, Python&#8217;s default &#8220;installation
prefix&#8221; is <tt class="file docutils literal"><span class="pre">C:\Python</span></tt>, so the system configuration file is normally
<tt class="file docutils literal"><span class="pre">C:\Python\Lib\distutils\distutils.cfg</span></tt>. Under Python 1.5.2, the
default prefix was <tt class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></tt>, and the Distutils were not
part of the standard library&#8212;so the system configuration file would be
<tt class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python\distutils\distutils.cfg</span></tt> in a standard Python
1.5.2 installation under Windows.</li>
<li>On Windows, if the <span class="target" id="index-5"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> environment variable is not defined,
<span class="target" id="index-6"></span><tt class="xref std std-envvar docutils literal"><span class="pre">USERPROFILE</span></tt> then <span class="target" id="index-7"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOMEDRIVE</span></tt> and <span class="target" id="index-8"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOMEPATH</span></tt> will
be tried. This is done by the <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></tt></a> function used
by Distutils.</li>
</ol>
</div>
<div class="section" id="syntax-of-config-files">
<span id="inst-config-syntax"></span><h3>Syntax of config files<a class="headerlink" href="#syntax-of-config-files" title="Permalink to this headline">¶</a></h3>
<p>The Distutils configuration files all have the same syntax.  The config files
are grouped into sections.  There is one section for each Distutils command,
plus a <tt class="docutils literal"><span class="pre">global</span></tt> section for global options that affect every command.  Each
section consists of one option per line, specified as <tt class="docutils literal"><span class="pre">option=value</span></tt>.</p>
<p>For example, the following is a complete config file that just forces all
commands to run quietly by default:</p>
<div class="highlight-none"><div class="highlight"><pre>[global]
verbose=0
</pre></div>
</div>
<p>If this is installed as the system config file, it will affect all processing of
any Python module distribution by any user on the current system.  If it is
installed as your personal config file (on systems that support them), it will
affect only module distributions processed by you.  And if it is used as the
<tt class="file docutils literal"><span class="pre">setup.cfg</span></tt> for a particular module distribution, it affects only that
distribution.</p>
<p>You could override the default &#8220;build base&#8221; directory and make the
<strong class="command">build*</strong> commands always forcibly rebuild all files with the
following:</p>
<div class="highlight-none"><div class="highlight"><pre>[build]
build-base=blib
force=1
</pre></div>
</div>
<p>which corresponds to the command-line arguments</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --build-base=blib --force
</pre></div>
</div>
<p>except that including the <strong class="command">build</strong> command on the command-line means
that command will be run.  Including a particular command in config files has no
such implication; it only means that if the command is run, the options in the
config file will apply.  (Or if other commands that derive values from it are
run, they will use the values in the config file.)</p>
<p>You can find out the complete list of options for any command using the
<a class="reference internal" href="../using/cmdline.html#cmdoption--help"><em class="xref std std-option">--help</em></a> option, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --help
</pre></div>
</div>
<p>and you can find out the complete list of global options by using
<a class="reference internal" href="../using/cmdline.html#cmdoption--help"><em class="xref std std-option">--help</em></a> without a command:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py --help
</pre></div>
</div>
<p>See also the &#8220;Reference&#8221; section of the &#8220;Distributing Python Modules&#8221; manual.</p>
</div>
</div>
<div class="section" id="building-extensions-tips-and-tricks">
<span id="inst-building-ext"></span><h2>Building Extensions: Tips and Tricks<a class="headerlink" href="#building-extensions-tips-and-tricks" title="Permalink to this headline">¶</a></h2>
<p>Whenever possible, the Distutils try to use the configuration information made
available by the Python interpreter used to run the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script.
For example, the same compiler and linker flags used to compile Python will also
be used for compiling extensions.  Usually this will work well, but in
complicated situations this might be inappropriate.  This section discusses how
to override the usual Distutils behaviour.</p>
<div class="section" id="tweaking-compiler-linker-flags">
<span id="inst-tweak-flags"></span><h3>Tweaking compiler/linker flags<a class="headerlink" href="#tweaking-compiler-linker-flags" title="Permalink to this headline">¶</a></h3>
<p>Compiling a Python extension written in C or C++ will sometimes require
specifying custom flags for the compiler and linker in order to use a particular
library or produce a special kind of object code. This is especially true if the
extension hasn&#8217;t been tested on your platform, or if you&#8217;re trying to
cross-compile Python.</p>
<p>In the most general case, the extension author might have foreseen that
compiling the extensions would be complicated, and provided a <tt class="file docutils literal"><span class="pre">Setup</span></tt> file
for you to edit.  This will likely only be done if the module distribution
contains many separate extension modules, or if they often require elaborate
sets of compiler flags in order to work.</p>
<p>A <tt class="file docutils literal"><span class="pre">Setup</span></tt> file, if present, is parsed in order to get a list of extensions
to build.  Each line in a <tt class="file docutils literal"><span class="pre">Setup</span></tt> describes a single module.  Lines have
the following structure:</p>
<div class="highlight-none"><div class="highlight"><pre>module ... [sourcefile ...] [cpparg ...] [library ...]
</pre></div>
</div>
<p>Let&#8217;s examine each of the fields in turn.</p>
<ul class="simple">
<li><em>module</em> is the name of the extension module to be built, and should be a
valid Python identifier.  You can&#8217;t just change this in order to rename a module
(edits to the source code would also be needed), so this should be left alone.</li>
<li><em>sourcefile</em> is anything that&#8217;s likely to be a source code file, at least
judging by the filename.  Filenames ending in <tt class="file docutils literal"><span class="pre">.c</span></tt> are assumed to be
written in C, filenames ending in <tt class="file docutils literal"><span class="pre">.C</span></tt>, <tt class="file docutils literal"><span class="pre">.cc</span></tt>, and <tt class="file docutils literal"><span class="pre">.c++</span></tt> are
assumed to be C++, and filenames ending in <tt class="file docutils literal"><span class="pre">.m</span></tt> or <tt class="file docutils literal"><span class="pre">.mm</span></tt> are assumed
to be in Objective C.</li>
<li><em>cpparg</em> is an argument for the C preprocessor,  and is anything starting with
<em class="xref std std-option">-I</em>, <em class="xref std std-option">-D</em>, <a class="reference internal" href="../using/cmdline.html#cmdoption-U"><em class="xref std std-option">-U</em></a> or <em class="xref std std-option">-C</em>.</li>
<li><em>library</em> is anything ending in <tt class="file docutils literal"><span class="pre">.a</span></tt> or beginning with <em class="xref std std-option">-l</em> or
<em class="xref std std-option">-L</em>.</li>
</ul>
<p>If a particular platform requires a special library on your platform, you can
add it by editing the <tt class="file docutils literal"><span class="pre">Setup</span></tt> file and running <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">build</span></tt>.
For example, if the module defined by the line</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c
</pre></div>
</div>
<p>must be linked with the math library <tt class="file docutils literal"><span class="pre">libm.a</span></tt> on your platform, simply add
<em class="xref std std-option">-lm</em> to the line:</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c -lm
</pre></div>
</div>
<p>Arbitrary switches intended for the compiler or the linker can be supplied with
the <em class="xref std std-option">-Xcompiler</em> <em>arg</em> and <em class="xref std std-option">-Xlinker</em> <em>arg</em> options:</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
</pre></div>
</div>
<p>The next option after <em class="xref std std-option">-Xcompiler</em> and <em class="xref std std-option">-Xlinker</em> will be
appended to the proper command line, so in the above example the compiler will
be passed the <em class="xref std std-option">-o32</em> option, and the linker will be passed
<em class="xref std std-option">-shared</em>.  If a compiler option requires an argument, you&#8217;ll have to
supply multiple <em class="xref std std-option">-Xcompiler</em> options; for example, to pass <tt class="docutils literal"><span class="pre">-x</span> <span class="pre">c++</span></tt>
the <tt class="file docutils literal"><span class="pre">Setup</span></tt> file would have to contain <tt class="docutils literal"><span class="pre">-Xcompiler</span> <span class="pre">-x</span> <span class="pre">-Xcompiler</span> <span class="pre">c++</span></tt>.</p>
<p>Compiler flags can also be supplied through setting the <span class="target" id="index-9"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></tt>
environment variable.  If set, the contents of <span class="target" id="index-10"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></tt> will be added to
the compiler flags specified in the  <tt class="file docutils literal"><span class="pre">Setup</span></tt> file.</p>
</div>
<div class="section" id="using-non-microsoft-compilers-on-windows">
<span id="inst-non-ms-compilers"></span><h3>Using non-Microsoft compilers on Windows<a class="headerlink" href="#using-non-microsoft-compilers-on-windows" title="Permalink to this headline">¶</a></h3>
<div class="section" id="borland-codegear-c">
<h4>Borland/CodeGear C++<a class="headerlink" href="#borland-codegear-c" title="Permalink to this headline">¶</a></h4>
<p>This subsection describes the necessary steps to use Distutils with the Borland
C++ compiler version 5.5.  First you have to know that Borland&#8217;s object file
format (OMF) is different from the format used by the Python version you can
download from the Python or ActiveState Web site.  (Python is built with
Microsoft Visual C++, which uses COFF as the object file format.) For this
reason you have to convert Python&#8217;s library <tt class="file docutils literal"><span class="pre">python25.lib</span></tt> into the
Borland format.  You can do this as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>coff2omf python25.lib python25_bcpp.lib
</pre></div>
</div>
<p>The <tt class="file docutils literal"><span class="pre">coff2omf</span></tt> program comes with the Borland compiler.  The file
<tt class="file docutils literal"><span class="pre">python25.lib</span></tt> is in the <tt class="file docutils literal"><span class="pre">Libs</span></tt> directory of your Python
installation.  If your extension uses other libraries (zlib, ...) you have to
convert them too.</p>
<p>The converted files have to reside in the same directories as the normal
libraries.</p>
<p>How does Distutils manage to use these libraries with their changed names?  If
the extension needs a library (eg. <tt class="file docutils literal"><span class="pre">foo</span></tt>) Distutils checks first if it
finds a library with suffix <tt class="file docutils literal"><span class="pre">_bcpp</span></tt> (eg. <tt class="file docutils literal"><span class="pre">foo_bcpp.lib</span></tt>) and then
uses this library.  In the case it doesn&#8217;t find such a special library it uses
the default name (<tt class="file docutils literal"><span class="pre">foo.lib</span></tt>.) <a class="footnote-reference" href="#id4" id="id1">[1]</a></p>
<p>To let Distutils compile your extension with Borland C++ you now have to type:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=bcpp
</pre></div>
</div>
<p>If you want to use the Borland C++ compiler as the default, you could specify
this in your personal or system-wide configuration file for Distutils (see
section <a class="reference internal" href="#inst-config-files"><em>Distutils Configuration Files</em></a>.)</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://www.codegear.com/downloads/free/cppbuilder">C++Builder Compiler</a></dt>
<dd>Information about the free C++ compiler from Borland, including links to the
download pages.</dd>
<dt><a class="reference external" href="http://www.cyberus.ca/~g_will/pyExtenDL.shtml">Creating Python Extensions Using Borland&#8217;s Free Compiler</a></dt>
<dd>Document describing how to use Borland&#8217;s free command-line C++ compiler to build
Python.</dd>
</dl>
</div>
</div>
<div class="section" id="gnu-c-cygwin-mingw">
<h4>GNU C / Cygwin / MinGW<a class="headerlink" href="#gnu-c-cygwin-mingw" title="Permalink to this headline">¶</a></h4>
<p>This section describes the necessary steps to use Distutils with the GNU C/C++
compilers in their Cygwin and MinGW distributions. <a class="footnote-reference" href="#id5" id="id2">[2]</a> For a Python interpreter
that was built with Cygwin, everything should work without any of these
following steps.</p>
<p>Not all extensions can be built with MinGW or Cygwin, but many can.  Extensions
most likely to not work are those that use C++ or depend on Microsoft Visual C
extensions.</p>
<p>To let Distutils compile your extension with Cygwin you have to type:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=cygwin
</pre></div>
</div>
<p>and for Cygwin in no-cygwin mode <a class="footnote-reference" href="#id6" id="id3">[3]</a> or for MinGW type:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=mingw32
</pre></div>
</div>
<p>If you want to use any of these options/compilers as default, you should
consider writing it in your personal or system-wide configuration file for
Distutils (see section <a class="reference internal" href="#inst-config-files"><em>Distutils Configuration Files</em></a>.)</p>
<div class="section" id="older-versions-of-python-and-mingw">
<h5>Older Versions of Python and MinGW<a class="headerlink" href="#older-versions-of-python-and-mingw" title="Permalink to this headline">¶</a></h5>
<p>The following instructions only apply if you&#8217;re using a version of Python
inferior to 2.4.1 with a MinGW inferior to 3.0.0 (with
binutils-2.13.90-20030111-1).</p>
<p>These compilers require some special libraries.  This task is more complex than
for Borland&#8217;s C++, because there is no program to convert the library.  First
you have to create a list of symbols which the Python DLL exports. (You can find
a good program for this task at
<a class="reference external" href="http://www.emmestech.com/software/pexports-0.43/download_pexports.html">http://www.emmestech.com/software/pexports-0.43/download_pexports.html</a>).</p>
<div class="highlight-none"><div class="highlight"><pre>pexports python25.dll &gt;python25.def
</pre></div>
</div>
<p>The location of an installed <tt class="file docutils literal"><span class="pre">python25.dll</span></tt> will depend on the
installation options and the version and language of Windows.  In a &#8220;just for
me&#8221; installation, it will appear in the root of the installation directory.  In
a shared installation, it will be located in the system directory.</p>
<p>Then you can create from these information an import library for gcc.</p>
<div class="highlight-none"><div class="highlight"><pre>/cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
</pre></div>
</div>
<p>The resulting library has to be placed in the same directory as
<tt class="file docutils literal"><span class="pre">python25.lib</span></tt>. (Should be the <tt class="file docutils literal"><span class="pre">libs</span></tt> directory under your Python
installation directory.)</p>
<p>If your extension uses other libraries (zlib,...) you might  have to convert
them too. The converted files have to reside in the same directories as the
normal libraries do.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://www.zope.org/Members/als/tips/win32_mingw_modules">Building Python modules on MS Windows platform with MinGW</a></dt>
<dd>Information about building the required libraries for the MinGW environment.</dd>
</dl>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This also means you could replace all existing COFF-libraries with OMF-libraries
of the same name.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Check <a class="reference external" href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a> and <a class="reference external" href="http://www.mingw.org/">http://www.mingw.org/</a> for more
information</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Then you have no POSIX emulation available, but you also don&#8217;t need
<tt class="file docutils literal"><span class="pre">cygwin1.dll</span></tt>.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Installing Python Modules</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#best-case-trivial-installation">Best case: trivial installation</a></li>
<li><a class="reference internal" href="#the-new-standard-distutils">The new standard: Distutils</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-build-and-install">Standard Build and Install</a><ul>
<li><a class="reference internal" href="#platform-variations">Platform variations</a></li>
<li><a class="reference internal" href="#splitting-the-job-up">Splitting the job up</a></li>
<li><a class="reference internal" href="#how-building-works">How building works</a></li>
<li><a class="reference internal" href="#how-installation-works">How installation works</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-installation">Alternate Installation</a><ul>
<li><a class="reference internal" href="#alternate-installation-the-user-scheme">Alternate installation: the user scheme</a></li>
<li><a class="reference internal" href="#alternate-installation-the-home-scheme">Alternate installation: the home scheme</a></li>
<li><a class="reference internal" href="#alternate-installation-unix-the-prefix-scheme">Alternate installation: Unix (the prefix scheme)</a></li>
<li><a class="reference internal" href="#alternate-installation-windows-the-prefix-scheme">Alternate installation: Windows (the prefix scheme)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-installation">Custom Installation</a><ul>
<li><a class="reference internal" href="#modifying-python-s-search-path">Modifying Python&#8217;s Search Path</a></li>
</ul>
</li>
<li><a class="reference internal" href="#distutils-configuration-files">Distutils Configuration Files</a><ul>
<li><a class="reference internal" href="#location-and-names-of-config-files">Location and names of config files</a></li>
<li><a class="reference internal" href="#syntax-of-config-files">Syntax of config files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-extensions-tips-and-tricks">Building Extensions: Tips and Tricks</a><ul>
<li><a class="reference internal" href="#tweaking-compiler-linker-flags">Tweaking compiler/linker flags</a></li>
<li><a class="reference internal" href="#using-non-microsoft-compilers-on-windows">Using non-Microsoft compilers on Windows</a><ul>
<li><a class="reference internal" href="#borland-codegear-c">Borland/CodeGear C++</a></li>
<li><a class="reference internal" href="#gnu-c-cygwin-mingw">GNU C / Cygwin / MinGW</a><ul>
<li><a class="reference internal" href="#older-versions-of-python-and-mingw">Older Versions of Python and MinGW</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../distutils/apiref.html"
                        title="previous chapter">10. API Reference</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../howto/index.html"
                        title="next chapter">Python HOWTOs</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/install/index.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../howto/index.html" title="Python HOWTOs"
             >next</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="10. API Reference"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <a href="../index.html">Python v2.7.4 documentation</a> &raquo;
        </li>
 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2013, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Apr 06, 2013.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>